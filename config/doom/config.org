#+title: Emacs Configuration
#+author: leniviy
#+property: header-args:emacs-lisp :tangle yes :comments link
#+property: header-args:elisp :exports code
#+property: header-args :tangle no :results silent :eval no-export
#+options: coverpage:yes
#+startup: overview

#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
# #+setupfile: https://b-coimbra.github.io/org-scribbler-theme/scribbler.setup

#+begin_quote
Let us change our traditional attitude to the construction of programs:
Instead of imagining that our main task is to instruct a computer what to do,
let us concentrate rather on explaining to human beings what we want a
computer to do. --- Donald Knuth
#+end_quote

-----

* Config
Make this file run (slightly) faster with lexical binding (see [[https://nullprogram.com/blog/2016/12/22/][this blog post]]
for more info).
#+begin_src emacs-lisp :comments no
;;; config.el -*- lexical-binding: t; -*-
#+end_src
** Personal information
Basic personal information
#+begin_src emacs-lisp
(setq user-full-name "Danylo Osipchuk"
      user-mail-address "xocada@gmail.com")
#+end_src
** Better defaults
*** Simple settings
Some better defaults from internet
#+begin_src emacs-lisp
(setq-default
 delete-by-moving-to-trash t                      ; Delete files to trash
 window-combination-resize t                      ; take new window space from all other windows (not just current)
 x-stretch-cursor t)                              ; Stretch cursor to the glyph width

(setq undo-limit 80000000                         ; Raise undo-limit to 80Mb
      evil-want-fine-undo t                       ; By default while in insert all changes are one big blob. Be more granular
      auto-save-default t                         ; Nobody likes to loose work, I certainly don't
      truncate-string-ellipsis "…")               ; Unicode ellispis are nicer than "...", and also save /precious/ space

(global-subword-mode 1)                           ; Iterate through CamelCase words
#+end_src
*** Frame sizing
It's nice to control the size of new frames, when launching Emacs that can be
done with ~emacs -geometry 160x48~. After the font size adjustment during
initialisation this works out to be ~102x31~.

Thanks to hotkeys, it's easy for me to expand a frame to half/full-screen, so it
makes sense to be conservative with the sizing of new frames.

Then, for creating new frames within the same Emacs instance, we'll just set the
default to be something roughly 80% of that size.

#+begin_src emacs-lisp
(add-to-list 'default-frame-alist '(height . 24))
(add-to-list 'default-frame-alist '(width . 80))
#+end_src
*** Auto-customisations
By default changes made via a customisation interface are added to =init.el=.
I prefer the idea of using a separate file for this. We just need to change a
setting, and load it if it exists.
#+begin_src emacs-lisp
(setq-default custom-file (expand-file-name ".custom.el" doom-private-dir))
(when (file-exists-p custom-file)
  (load custom-file))
#+end_src
*** Windows
I find it rather handy to be asked which buffer I want to see after splitting
the window. Let's make that happen.
First, we'll enter the new window
#+begin_src emacs-lisp
(setq evil-vsplit-window-right t
      evil-split-window-below t)
#+end_src

Then, we'll pull up a buffer prompt.
#+begin_src emacs-lisp
(defadvice! prompt-for-buffer (&rest _)
  :after '(evil-window-split evil-window-vsplit)
  (consult-buffer))
#+end_src
# Oh, and previews are nice
# #+begin_src emacs-lisp
# (setq +ivy-buffer-preview t)
# #+end_src

Window rotation is nice, and can be found under =SPC w r= and =SPC w R=.
/Layout/ rotation is also nice though. Let's stash this under =SPC w SPC=, inspired
by Tmux's use of =C-b SPC= to rotate windows.

We could also do with adding the missing arrow-key variants of the window
navigation/swapping commands.
#+begin_src emacs-lisp
(map! :map evil-window-map
      "SPC" #'rotate-layout
      ;; Navigation
      "<left>"     #'evil-window-left
      "<down>"     #'evil-window-down
      "<up>"       #'evil-window-up
      "<right>"    #'evil-window-right
      ;; Swapping windows
      "C-<left>"       #'+evil/window-move-left
      "C-<down>"       #'+evil/window-move-down
      "C-<up>"         #'+evil/window-move-up
      "C-<right>"      #'+evil/window-move-right)
#+end_src

** Doom configuration
*** Modules
:PROPERTIES:
:header-args:emacs-lisp: :tangle no
:END:
Doom has this lovely /modular configuration base/ that takes a lot of work out of
configuring Emacs. Each module (when enabled) can provide a list of packages to
install (on ~doom sync~) and configuration to be applied. The modules can also
have flags applied to tweak their behaviour.

#+name: init.el
#+attr_html: :collapsed t
#+begin_src emacs-lisp :tangle "init.el" :noweb no-export :comments none
;;; init.el -*- lexical-binding: t; -*-

;; This file controls what Doom modules are enabled and what order they load in.
;; Press 'K' on a module to view its documentation, and 'gd' to browse its directory.

(doom! :completion
       <<doom-completion>>

       :ui
       <<doom-ui>>

       :editor
       <<doom-editor>>

       :emacs
       <<doom-emacs>>

       :term
       <<doom-term>>

       :checkers
       <<doom-checkers>>

       :tools
       <<doom-tools>>

       :os
       <<doom-os>>

       :lang
       <<doom-lang>>

       :email
       <<doom-email>>

       :app
       <<doom-app>>

       :config
       <<doom-config>>
       )
#+end_src
**** Structure
As you may have noticed by this point, this is a [[https://en.wikipedia.org/wiki/Literate_programming][literate]] configuration. Doom
has good support for this which we access though the ~literate~ module.

While we're in the ~:config~ section, we'll use Dooms nicer defaults, along with
the bindings and smartparens behaviour (the flags aren't documented, but they exist).
#+name: doom-config
#+begin_src emacs-lisp
literate
(default +bindings +smartparens)
#+end_src

**** Interface
#+name: doom-completion
#+begin_src emacs-lisp
(company                     ; the ultimate code completion backend
 +childframe)                ; ... when your children are better than you
;;helm                       ; the *other* search engine for love and life
;;ido                        ; the other *other* search engine...
;; (ivy                         ; a search engine for love and life
;;  +icons                      ; ... icons are nice
;;  +childframe                 ; ... when your children are better than you
;;  +prescient)                 ; ... I know what I want(ed)
(vertico +icons
         ;; +childframe
         )
#+end_src


#+name: doom-ui
#+begin_src emacs-lisp
;;deft                       ; notational velocity for Emacs
doom                         ; what makes DOOM look the way it does
doom-dashboard               ; a nifty splash screen for Emacs
doom-quit                    ; DOOM quit-message prompts when you quit Emacs
(emoji                       ; 🙂
 +unicode
 +github)
;;fill-column                ; a `fill-column' indicator
hl-todo                      ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW
hydra                      ; quick documentation for related commands
indent-guides              ; highlighted indent columns, notoriously slow
(ligatures
 +pragmata-pro
 +iosevka
 +extra
)           ; ligatures and symbols to make your code pretty again
minimap                    ; show a map of the code on the side
modeline                     ; snazzy, Atom-inspired modeline, plus API
nav-flash                    ; blink the current line after jumping
;;neotree                    ; a project drawer, like NERDTree for vim
ophints                      ; highlight the region an operation acts on
(popup                       ; tame sudden yet inevitable temporary windows
 +all                        ; catch all popups that start with an asterix
 +defaults)                  ; default popup rules
;;(tabs                      ; an tab bar for Emacs
;;  +centaur-tabs)           ; ... with prettier tabs
(treemacs                     ; a project drawer, like neotree but cooler
 +lsp)
unicode                    ; extended unicode support for various languages
(vc-gutter                    ; vcs diff in the fringe
 +pretty
 +diff-hl
 )
vi-tilde-fringe              ; fringe tildes to mark beyond EOB
window-select                ; visually switch windows
workspaces                   ; tab emulation, persistence & separate workspaces
zen                          ; distraction-free coding or writing
#+end_src

#+name: doom-editor
#+begin_src emacs-lisp
(evil +everywhere)           ; come to the dark side, we have cookies
file-templates               ; auto-snippets for empty files
fold                         ; (nigh) universal code folding
format             ; automated prettiness
;;god                        ; run Emacs commands without modifier keys
;;lispy                      ; vim for lisp, for people who don't like vim
multiple-cursors             ; editing in many places at once
;;objed                      ; text object editing for the innocent
;;parinfer                   ; turn lisp into python, sort of
rotate-text                  ; cycle region at point between text candidates
snippets                     ; my elves. They type so I don't have to
;;word-wrap                  ; soft wrapping with language-aware indent
#+end_src

#+name: doom-emacs
#+begin_src emacs-lisp
(dired
 +icons
 ;; +ranger
 +dirvish
 )               ; making dired pretty [functional]
electric                     ; smarter, keyword-based electric-indent
(ibuffer +icons)             ; interactive buffer management
(undo +tree)                 ; persistent, smarter undo for your inevitable mistakes
vc                           ; version-control and Emacs, sitting in a tree
#+end_src


#+name: doom-term
#+begin_src emacs-lisp
eshell            ; a consistent, cross-platform shell (WIP)
;; shell             ; a terminal REPL for Emacs
;; term              ; terminals in Emacs
vterm             ; another terminals in Emacs
#+end_src

#+name: doom-checkers
#+begin_src emacs-lisp
(syntax                       ; tasing you for every semicolon you forget
 +flymake
 +childframe)
(spell +aspell)                        ; tasing you for misspelling mispelling
grammar                      ; tasing grammar mistake every you make
#+end_src

#+name: doom-tools
#+begin_src emacs-lisp
;; ansible                      ; a crucible for infrastructure as code
biblio
;; (
debugger                     ; FIXME stepping through code, to help you add bugs
;;+lsp)
direnv                     ; be direct about your environment
docker                     ; port everything to containers
editorconfig               ; let someone else argue about tabs vs spaces
;;ein                        ; tame Jupyter notebooks with emacs
(eval +overlay)              ; run code, run (also, repls)
gist                       ; interacting with github gists
(lookup                      ; helps you navigate your code and documentation
 +dictionary                 ; dictionary/thesaurus is nice
 +docsets)                   ; ...or in Dash docsets locally
(lsp +peek)                          ; Language Server Protocol
(magit                       ; a git porcelain for Emacs
 ;; +forge
 )                     ; interface with git forges
make                         ; run make tasks from Emacs
pass                       ; password manager for nerds
pdf                          ; pdf enhancements
;;prodigy                    ; FIXME managing external services & code builders
rgb                          ; creating color strings
;;taskrunner                 ; taskrunner for all your projects
;;terraform                  ; infrastructure as code
tmux                       ; an API for interacting with tmux
upload                       ; map local to remote projects via ssh/ftp
tree-sitter
#+end_src

#+name: doom-os
#+begin_src emacs-lisp
(:if IS-MAC macos)  ; improve compatibility with macOS
(tty +osc)                          ; improve the terminal Emacs experience
#+end_src
**** Language support
#+name: doom-lang
#+begin_src emacs-lisp
;;agda              ; types of types of types of types...
;;assembly          ; assembly for fun or debugging
(cc +lsp +tree-sitter)                ; C/C++/Obj-C madness
;;clojure           ; java with a lisp
common-lisp       ; if you've seen one lisp, you've seen them all
;;coq               ; proofs-as-programs
;;crystal           ; ruby at the speed of c
(csharp
 +lsp
 ;; +unity
 +tree-sitter
 +dotnet)            ; unity, .NET, and mono shenanigans
data              ; config/data formats
;; (dart +flutter +lsp)   ; paint ui and not much else
;;erlang            ; an elegant language for a more civilized age
ess                          ; emacs speaks statistics
(elixir
 +lsp
 )                                        ; erlang done right
;;elm               ; care for a cup of TEA?
emacs-lisp        ; drown in parentheses
;;ess               ; emacs speaks statistics
(fsharp           ; ML stands for Microsoft's Language
 +lsp
 )
(go +lsp +tree-sitter)                ; the hipster dialect
(haskell             ; a language that's lazier than I am
 +lsp
 +tree-sitter
 )
;;hy                ; readability of scheme w/ speed of python
;;idris             ;
;;(java +meghanada) ; the poster child for carpal tunnel syndrome
(javascript
 +lsp
 +tree-sitter
 )        ; all(hope(abandon(ye(who(enter(here))))))

(json +lsp +tree-sitter)
;;julia             ; a better, faster MATLAB
(kotlin +lsp +tree-sitter)            ; a better, slicker Java(Script)
(latex
 +lsp
 +cdlatex
 +latexmk
 +fold)            ; writing papers in Emacs has never been so fun
;;ledger            ; an accounting system in Emacs
lua               ; one-based indices? one-based indices
(markdown +grip)         ; writing docs for people to ignore
;;nim               ; python + lisp at the speed of c
(nix
 +tree-sitter
 )               ; I hereby declare "nix geht mehr!"
;;ocaml             ; an objective camel
(org              ; organize your plain life in plain text
 ;; +pretty       ; Disable since I use org-modern
 +pandoc
 +dragndrop       ; file drag & drop support
 +noter                      ; enhanced PDF notetaking
 +present         ; using Emacs for presentations
 +gnuplot
 +journal
 +roam2
 )
;;perl              ; write code no one else can comprehend
(php +lsp +tree-sitter)               ; perl's insecure younger brother
;;plantuml          ; diagrams for confusing people more
;;purescript        ; javascript, but functional
(python
 +lsp
 +tree-sitter
 )           ; beautiful is better than ugly
;;qt                ; the 'cutest' gui framework ever
;;racket            ; a DSL for DSLs
;;rest              ; Emacs as a REST client
;;ruby              ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
(rust
 +lsp
 +tree-sitter
 )            ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
(scala +lsp)             ; java, but good
scheme            ; a fully conniving family of lisps
(sh +lsp +tree-sitter)                ; she sells {ba,z,fi}sh shells on the C xor
solidity          ; do you need a blockchain? No.
;;swift             ; who asked for emoji variables?
;;terra             ; Earth and Moon in alignment for performance.
(web +lsp +tree-sitter)              ; the tubes
(yaml +lsp +tree-sitter)
;; graphql
;;vala              ; GObjective-C
#+end_src
**** Everything in Emacs
It's just too convenient being able to have everything in Emacs.
I couldn't resist the Email and Feed modules.

#+name: doom-email
#+begin_src emacs-lisp
(mu4e +org +gmail)
;;notmuch
;;(wanderlust +gmail)
#+end_src

#+name: doom-app
#+begin_src emacs-lisp
calendar
everywhere                   ; *leave* Emacs!? You must be joking.
irc                          ; how neckbeards socialize
(rss +org)                   ; emacs as an RSS reader
;;twitter                    ; twitter client https://twitter.com/vnought
#+end_src

*** Visual settings
**** Font Face
Use font aliases defined in fontconfig.
#+begin_src emacs-lisp
;; (setq! doom-font (font-spec :family "monospace" :size 16)
;;        ;; doom-big-font (font-spec :family "monospace" :size 26)
;;        doom-variable-pitch-font (font-spec :family "sans" :size 16)
;;        ;; doom-unicode-font (font-spec :family "JuliaMono")
;;        doom-unicode-font doom-variable-pitch-font
;;        ;; doom-unicode-font doom-font
;;        doom-serif-font doom-variable-pitch-font
;;        )

(setq doom-font (font-spec :family "monospace" :size 16)
      doom-big-font (font-spec :family "monospace" :size 26)
      doom-variable-pitch-font (font-spec :family "sans" :size 16)
      ;; doom-unicode-font (font-spec :family "JuliaMono")
      doom-unicode-font doom-variable-pitch-font
      doom-serif-font doom-variable-pitch-font)

;; Fix cyryllic fonts
;; (if (display-graphic-p)

;;     (dolist (charset '(koi8))
;;       (set-fontset-font (frame-parameter nil 'font)
;;                         charset (font-spec :family "sans" :height 90)))

;;   (after! unicode-fonts
;;     (dolist (unicode-block '("Cyrillic"
;;                              "Cyrillic Supplement"))
;;       (push "sans" (cadr (assoc unicode-block unicode-fonts-block-font-mapping)))))

;;   )
#+end_src
**** Theme and modeline
#+begin_src emacs-lisp
(setq doom-theme 'doom-tomorrow-night)
#+end_src

I don't need it to tell me its UTF-8
#+begin_src emacs-lisp
;; I don't need it to tell me its UTF-8
(setq doom-modeline-buffer-encoding nil
      +modeline-encoding nil)
#+end_src
**** Miscellaneous
Relative line numbers are fantastic for knowing how far away line numbers are,
then =ESC 12 <UP>= gets you exactly where you think.
#+begin_src emacs-lisp
(setq display-line-numbers-type 'relative)
#+end_src

Prevents some cases of Emacs flickering
#+begin_src emacs-lisp
(add-to-list 'default-frame-alist '(inhibit-double-buffering . t))
#+end_src

 Don't blink the cursor, it's too distracting.
 #+begin_src emacs-lisp
(setq visible-cursor nil
      blink-cursor-mode -1)
#+end_src
**** Ligatures
I really don't like some ligatures so disabling them here.
#+begin_src emacs-lisp
(plist-put! +ligatures-extra-symbols
  :int           nil
  :name          nil
  :composition   nil
  :map           nil
  :not           nil
  :and           nil
  :or            nil
  :for           nil
  :return        nil
  :yield         nil
  :diff          nil
  :tuple         nil
  :pipe          nil
)
#+end_src
**** Scrolling
Smooth scrolling in emacs
#+begin_src emacs-lisp :tangle packages.el
(package! good-scroll)
#+end_src
#+begin_src emacs-lisp
(use-package! good-scroll
  :config
  (good-scroll-mode)
)
#+end_src

**** Prettier page breaks

In some files, =^L= appears as a page break character. This isn't that visually
appealing, and Steve Purcell has been nice enough to make a package to display
these as horizontal rules.
#+begin_src emacs-lisp :tangle packages.el
(package! page-break-lines :recipe (:host github :repo "purcell/page-break-lines")
  :pin "79eca86e0634ac68af862e15c8a236c37f446dcd")
#+end_src

#+begin_src emacs-lisp
(use-package! page-break-lines
  :commands page-break-lines-mode
  :init
  (autoload 'turn-on-page-break-lines-mode "page-break-lines")
  :config
  (setq page-break-lines-max-width fill-column)
  (map! :prefix "g"
        :desc "Prev page break" :nv "[" #'backward-page
        :desc "Next page break" :nv "]" #'forward-page))
#+end_src

*** Allow babel execution in CLI actions
In this config I sometimes generate code to include in my config.
This works nicely, but for it to work with =doom sync= et. al. I need to make sure
that Org doesn't try to confirm that I want to allow evaluation (I do!).

Thankfully Doom supports =$DOOMDIR/cli.el= file which is sourced every time a CLI
command is run, so we can just enable evaluation by setting
~org-confirm-babel-evaluate~ to ~nil~ there.
While we're at it, we should silence ~org-babel-execute-src-block~ to
avoid polluting the output.

#+begin_src emacs-lisp :tangle cli.el :comments none
;;; cli.el -*- lexical-binding: t; -*-
(setq org-confirm-babel-evaluate nil)

(defun doom-shut-up-a (orig-fn &rest args)
  (quiet! (apply orig-fn args)))

(advice-add 'org-babel-execute-src-block :around #'doom-shut-up-a)
#+end_src
# ** Emacs-ng
# #+begin_src emacs-lisp
# (setq ng-straight-bootstrap-at-startup t)
# #+end_src
** Performance
#+begin_src emacs-lisp
(setq gcmh-high-cons-threshold most-positive-fixnum)
(setq max-specpdl-size 100000)
#+end_src
** Other Things
*** Editor interaction
**** Mouse buttons
#+begin_src emacs-lisp
(map! :n [mouse-8] #'better-jumper-jump-backward
      :n [mouse-9] #'better-jumper-jump-forward)
#+end_src
*** Splash screen
Splash image
#+begin_src emacs-lisp
(setq fancy-splash-image (concat doom-private-dir "splash.png"))
#+end_src

Hide modeline and cursor
#+begin_src emacs-lisp
(remove-hook '+doom-dashboard-functions #'doom-dashboard-widget-loaded)
(add-hook! '+doom-dashboard-mode-hook (hide-mode-line-mode 1) (hl-line-mode -1))
(setq-hook! '+doom-dashboard-mode-hook evil-normal-state-cursor (list nil))
#+end_src
*** Daemon
**** Dashboard
I'm not sure quite why it happens, but after a bit it seems that
new Emacsclient frames start on the =*scratch*= buffer instead of the dashboard.
I prefer the dashboard, so let's ensure that's always switched to in new frames.

#+name: daemon initialization
#+begin_src emacs-lisp
(when (daemonp)
  (add-hook! 'server-after-make-frame-hook (switch-to-buffer +doom-dashboard-name)))
#+end_src
* Package loading
:PROPERTIES:
:header-args:emacs-lisp: :tangle "packages.el" :comments no
:END:
This file shouldn't be byte compiled.
#+begin_src emacs-lisp :tangle "packages.el" :comments no
;; -*- no-byte-compile: t; -*-
#+end_src
** General packages
*** Fun
Every so often, you want everyone else to /know/ that you're typing, or just to
amuse oneself. Introducing: typewriter sounds!
#+begin_src emacs-lisp
(package! selectric-mode)
#+end_src

Practice typing speed
#+begin_src emacs-lisp
(package! speed-type)
#+end_src

Why not flash words on the screen. Why not --- hey, it could be fun.
#+begin_src emacs-lisp
(package! spray)
#+end_src

For some reason, I find myself demoing Emacs every now and then. Showing what
keyboard stuff I'm doing on-screen seems helpful. While [[https://gitlab.com/screenkey/screenkey][screenkey]] does exist,
having something that doesn't cover up screen content is nice.
#+begin_src emacs-lisp
(package! keycast)
#+end_src

In a similar manner, [[https://gitlab.com/ambrevar/emacs-gif-screencast][gif-screencast]] may come in handy.
#+begin_src emacs-lisp
(package! gif-screencast)
#+end_src

*** Features
**** CalcTeX
This is a nice extension to ~calc~
#+begin_src emacs-lisp
(package! calctex :recipe (:host github :repo "johnbcoughlin/calctex"
                           :files ("*.el" "calctex/*.el" "calctex-contrib/*.el" "org-calctex/*.el"))
)
#+end_src
**** Info colors
This makes manual pages nicer to look at :)
Variable pitch fontification + colouring
#+begin_src emacs-lisp
(package! info-colors :pin "47ee73cc19b1049eef32c9f3e264ea7ef2aaf8a5")
#+end_src

**** Calibre and ebook reading
For managing my ebooks, I'll hook into the well-established ebook library
manager [[https://calibre-ebook.com/][calibre]]. A number of Emacs clients for this exist, but this seems like a
good option.
#+begin_src emacs-lisp
(package! calibredb)
#+end_src

Then for reading them, the only currently viable options seems to be [[https://depp.brause.cc/nov.el/][nov.el]].
#+begin_src emacs-lisp
(package! nov)
#+end_src

Together these should give me a rather good experience reading ebooks.
**** Screenshots
This makes it a breeze to take lovely screenshots.
#+begin_src emacs-lisp
(package! screenshot :recipe (:host github :repo "tecosaur/screenshot" :build (:not compile)))
#+end_src
**** Theme schedule
#+begin_src emacs-lisp
(package! circadian)
#+end_src
**** Non-default keyboard layouts support
#+begin_src emacs-lisp
(package! reverse-im)
#+end_src
**** Kdeconnect
#+begin_src emacs-lisp
(package! kdeconnect)
#+end_src
**** Imenu
#+begin_src emacs-lisp
(package! imenu-list)
#+end_src
**** Deadgrep
#+begin_src emacs-lisp
(package! deadgrep)
#+end_src
**** Company
*****  Prescient
#+begin_src emacs-lisp
(package! company-prescient)
#+end_src
*****  Fuzzy
#+begin_src emacs-lisp
(package! company-fuzzy)
(package! flx)
;; (package! flx-rs)
#+end_src
*****  Math
#+begin_src emacs-lisp
(package! company-math)
#+end_src
**** Top in emacs
#+begin_src emacs-lisp
(package! explain-pause-mode)
#+end_src
**** Google-translate
#+begin_src emacs-lisp
(package! go-translate)
#+end_src
**** Timesheet
#+begin_src emacs-lisp
(package! timesheet)
#+end_src
**** Wakatime
#+begin_src emacs-lisp
(package! wakatime-mode)
#+end_src
**** iscroll
Sometimes it's nice to have smooth scrolling over images

#+begin_src emacs-lisp
(package! iscroll :recipe (:host github
                           :repo "casouri/iscroll"))
#+end_src
** Language packages
*** LaTeX
For mathematical convenience, WIP
#+begin_src emacs-lisp
(package! aas :recipe (:host github :repo "ymarco/auto-activating-snippets"))
(package! laas :recipe (:host github :repo "tecosaur/LaTeX-auto-activating-snippets"))
#+end_src
And some basic config
#+begin_src emacs-lisp :tangle yes
(use-package! aas
  :commands aas-mode)

(use-package! laas
  :hook ((org-mode . laas-mode)
         (org-mode . aas-activate-for-major-mode)
         (LaTeX-mode . laas-mode))
  :config
  (defun laas-tex-fold-maybe ()
    (unless (equal "/" aas-transient-snippet-key)
      (+latex-fold-last-macro-a)))
  (add-hook 'aas-post-snippet-expand-hook #'laas-tex-fold-maybe))
#+end_src
*** Org Mode
**** Improve agenda/capture
The agenda is nice, but a souped up version is nicer.
#+begin_src emacs-lisp
(package! org-super-agenda)
#+end_src

Similarly ~doct~ (Declarative Org Capture Templates) seems to be a nicer way to
set up org-capture.
#+begin_src emacs-lisp
(package! doct
  :recipe (:host github :repo "progfolio/doct")
  )
#+end_src
**** Visuals
For automatically toggling LaTeX fragment previews there's this nice package
#+begin_src emacs-lisp
(package! org-fragtog)
#+end_src

Then for pretty markers
#+begin_src emacs-lisp
(package! org-appear :recipe (:host github :repo "awth13/org-appear"))
#+end_src

~org-superstar-mode~ is great. While we're at it we may as well make tags prettier as well :)
#+begin_src emacs-lisp
(package! org-pretty-tags)
#+end_src

There's this nice package that can provide nice syntax highlighting with LaTeX
exports.
#+begin_src emacs-lisp
(package! engrave-faces :recipe (:host github :repo "tecosaur/engrave-faces"))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! engrave-faces-latex
  :after ox-latex)
#+end_src
**** Extra functionality
Because of the /[[https://github.com/commonmark/commonmark-spec/wiki/markdown-flavors][lovely variety in markdown implementations]]/ there isn't actually
such a thing a standard table spec ... or standard anything really. Because
~org-md~ is a goody-two-shoes, it just uses HTML for all these non-standardised
elements (a lot of them). So ~ox-gfm~ is handy for exporting markdown with all the
features that GitHub has.
#+begin_src emacs-lisp
(package! ox-gfm)
#+end_src
#+begin_src emacs-lisp :tangle yes
(use-package! ox-gfm
  :after org)
#+end_src

Now and then citations need to happen
#+begin_src emacs-lisp
(package! org-ref)
#+end_src

# Came across this and ... it's cool
# #+begin_src emacs-lisp
# (package! org-graph-view :recipe (:host github :repo "alphapapa/org-graph-view"))
# #+end_src

I *need* this in my life. It take a URL to a recipe from a common site, and
inserts an org-ified version at point. Isn't that just great.
#+begin_src emacs-lisp
(package! org-chef)
#+end_src

Sometimes I'm given non-org files, that's very sad. Luckily Pandoc offers a way
to make that right again, and this package makes that even easier to do.
#+begin_src emacs-lisp
(package! org-pandoc-import :recipe
  (:host github :repo "tecosaur/org-pandoc-import" :files ("*.el" "filters" "preprocessors")))
#+end_src
#+begin_src emacs-lisp :tangle yes
(use-package! org-pandoc-import
  :after org)
#+end_src

#+begin_src emacs-lisp
(package! ob-mermaid)
#+end_src

#+begin_src emacs-lisp
(package! org-modern)
#+end_src

#+begin_src emacs-lisp
(package! org-appear :recipe (:host github :repo "awth13/org-appear")
  :pin "60ba267c5da336e75e603f8c7ab3f44e6f4e4dac")
#+end_src

It's nice to have UI for org-roam
#+begin_src emacs-lisp
(package! org-roam-ui)
(package! websocket)
#+end_src

#+begin_src emacs-lisp
(package! org-transclusion)
#+end_src

Let's have media notes in org-mode
#+begin_src emacs-lisp
(package! pretty-hydra)  ;; dependency
(package! org-media-note :recipe (:host github :repo "yuchen-lea/org-media-note"))
#+end_src

*** Systemd
For editing systemd unit files
#+begin_src emacs-lisp
(package! systemd :pin "b6ae63a236605b1c5e1069f7d3afe06ae32a7bae")
#+end_src
*** Graphviz
Graphviz is a nice method of visualising simple graphs, based on plaintext
=.dot= / =.gv= files.
#+begin_src emacs-lisp
(package! graphviz-dot-mode :pin "3642a0a5f41a80c8ecef7c6143d514200b80e194")
#+end_src
*** Authinfo
#+begin_src emacs-lisp
(package! authinfo-color-mode
  :recipe (:host github :repo  "tecosaur/authinfo-color-mode"))
#+end_src
Now we just need to load it appropriately.
#+begin_src emacs-lisp :tangle yes
(use-package! authinfo-color-mode
  :mode ("authinfo.gpg\\'" . authinfo-color-mode)
  :init (advice-add 'authinfo-mode :override #'authinfo-color-mode))
#+end_src
* Package configuration
** Abbrev mode
Thanks to [[https://emacs.stackexchange.com/questions/45462/use-a-single-abbrev-table-for-multiple-modes/45476#45476][use a single abbrev-table for multiple modes? - Emacs Stack Exchange]] I
have the following.
#+begin_src emacs-lisp
(use-package abbrev
  :init
  (setq-default abbrev-mode t)
  ;; a hook funtion that sets the abbrev-table to org-mode-abbrev-table
  ;; whenever the major mode is a text mode
  (defun tec/set-text-mode-abbrev-table ()
    (if (derived-mode-p 'text-mode)
        (setq local-abbrev-table org-mode-abbrev-table)))
  :commands abbrev-mode
  :hook
  (abbrev-mode . tec/set-text-mode-abbrev-table)
  :config
  (setq abbrev-file-name (expand-file-name "abbrev.el" doom-private-dir))
  (setq save-abbrevs 'silently))
#+end_src
** Avy
I want avy to jump though windows and auto-jump when theres 1 candidate
#+begin_src  emacs-lisp
(setq
 ;; Avy can jump through windows
 avy-all-windows t
 ;; Avy can auto-jump when theres 1 candidate
 avy-single-candidate-jump t)
#+end_src
** Calc
#+begin_src emacs-lisp
(add-hook 'calc-mode-hook #'calctex-mode)
#+end_src
** Circadian (Theme schedule)
#+begin_src emacs-lisp
(use-package! circadian
  :config
  (setq circadian-themes '(("8:00" . doom-tomorrow-night)
                           ("20:30" . doom-tomorrow-night)))
  (circadian-setup)
)
#+end_src
# ** Modus themes
# #+begin_src emacs-lisp :tangle packages.el
# (package! modus-themes)
# #+end_src

# #+begin_src emacs-lisp
# (use-package modus-themes
#   :config
#   (setq modus-themes-slanted-constructs t
#         modus-themes-bold-constructs t
#         modus-themes-subtle-line-numbers t
#         modus-themes-paren-match 'intense-bold
#         modus-themes-prompts 'subtle-accented
#         modus-themes-completions nil
#         modus-themes-region 'accent-no-extend
#         modus-themes-syntax 'alt-syntax-yellow-comments
#         modus-themes-scale-headings t
#         modus-themes-headings '((t . rainbow))
#         modus-themes-mode-line 'borderless
#         modus-themes-org-blocks 'grayscale
#         )
#   )
# #+end_src
** Company
Some settings
#+begin_src emacs-lisp
(after! company
  (setq
   company-show-numbers t
   company-minimum-prefix-length 2
   )
  )
#+end_src

Now, the improvements from ~precedent~ are mostly from remembering history, so
let's improve that memory.
#+begin_src emacs-lisp
(setq-default history-length 1000)
(setq-default prescient-history-length 1000)
#+end_src

Use prescient sorting
#+begin_src emacs-lisp
(use-package company-prescient
  :after company
  :hook (company-mode . company-prescient-mode))
#+end_src

# Use fuzzy sorting
# #+begin_src emacs-lisp
# (use-package! company-fuzzy
#   :hook (company-mode . company-fuzzy-mode)
#   :init
#   (setq
#    company-fuzzy-sorting-backend 'flx
#    ;; company-fuzzy-sorting-backend 'alphabetical
#    company-fuzzy-prefix-on-top nil
#    company-fuzzy-history-backends '(company-yasnippet)
#    company-fuzzy-trigger-symbols '("." "->" "<" "\"" "'" "@"))
#   )
# #+end_src

Math support
#+begin_src emacs-lisp
(use-package! company-math
  :after (:any org-mode TeX-mode)
  :config
  (set-company-backend! 'org-mode 'company-math-symbols-latex)
  (set-company-backend! 'TeX-mode 'company-math-symbols-latex)
  (set-company-backend! 'org-mode 'company-latex-commands)
  (set-company-backend! 'TeX-mode 'company-latex-commands)
  (setq company-tooltip-align-annotations t)
  (setq company-math-allow-latex-symbols-in-faces t))
#+end_src
*** ESS
** Deadgrep
#+begin_src emacs-lisp
(use-package! deadgrep
  :defer t
  :init
  (map!
   (:leader
    :desc "Search via deadgrep" "s <f5>" #'deadgrep))
  )
#+end_src
** Direnv
Silence all that useless output
#+begin_src emacs-lisp
(setq direnv-always-show-summary nil)
#+end_src
** Doom modeline
Very nice and pretty, however I think the PDF modeline could do with tweaking.
I raised [[https://github.com/seagle0128/doom-modeline/pull/425][an issue]] on this, however the response was basically "put your
preferences in your personal config, the current default is sensible" --- so
here we are.

First up I'm going to want a segment for just the buffer file name, and a PDF
icon. Then we'll redefine two functions used to generate the modeline.

#+begin_src emacs-lisp
(after! doom-modeline
  (doom-modeline-def-segment buffer-name
    "Display the current buffer's name, without any other information."
    (concat
     (doom-modeline-spc)
     (doom-modeline--buffer-name)))

  (doom-modeline-def-segment pdf-icon
    "PDF icon from all-the-icons."
    (concat
     (doom-modeline-spc)
     (doom-modeline-icon 'octicon "file-pdf" nil nil
                         :face (if (doom-modeline--active)
                                   'all-the-icons-red
                                 'mode-line-inactive)
                         :v-adjust 0.02)))

  (defun doom-modeline-update-pdf-pages ()
    "Update PDF pages."
    (setq doom-modeline--pdf-pages
          (let ((current-page-str (number-to-string (eval `(pdf-view-current-page))))
                (total-page-str (number-to-string (pdf-cache-number-of-pages))))
            (concat
             (propertize
              (concat (make-string (- (length total-page-str) (length current-page-str)) ? )
                      " P" current-page-str)
              'face 'mode-line)
             (propertize (concat "/" total-page-str) 'face 'doom-modeline-buffer-minor-mode)))))

  (doom-modeline-def-segment pdf-pages
    "Display PDF pages."
    (if (doom-modeline--active) doom-modeline--pdf-pages
      (propertize doom-modeline--pdf-pages 'face 'mode-line-inactive)))

  (doom-modeline-def-modeline 'pdf
    '(bar window-number pdf-pages pdf-icon buffer-name)
    '(misc-info matches major-mode process vcs)))
#+end_src
** Emacs-everywhere
Configure it a bit
#+begin_src emacs-lisp
(after! emacs-everywhere
  ;;   Make it easier to match with xmonad rule
  (setq emacs-everywhere-frame-name-format "emacs-anywhere")

  ;; The modeline is not useful to me in the popup window. It looks much nicer
  ;; to hide it.
  (remove-hook 'emacs-everywhere-init-hooks #'hide-mode-line-mode)
  (remove-hook! 'emacs-everywhere-init-hooks #'emacs-everywhere-set-frame-position)
  )
#+end_src
** Eros-eval
This makes the result of evals with =gr= and =gR= just slightly prettier. Every bit
counts right?
#+begin_src emacs-lisp
(setq eros-eval-result-prefix "⟹ ")
#+end_src
** EVIL
When I want to make a substitution, I want it to be global more often than not
--- so let's make that the default.

Now, EVIL cares a fair bit about keeping compatibility with Vim's default
behaviour. I don't. There are some particular settings that I'd rather be
something else, so let's change them.

#+begin_src emacs-lisp
(after! evil
  (setq evil-ex-substitute-global t     ; I like my s/../.. to by global by default
        evil-move-cursor-back nil       ; Don't move the block cursor when toggling insert mode
        evil-kill-on-visual-paste nil)) ; Don't put overwritten text in the kill ring
#+end_src

I don't use ~evil-escape-mode~, so I may as well turn it off, I've heard it
contributes a typing delay. I'm not sure it's much, but it is an extra
~pre-command-hook~ that I don't benefit from, so...
It seems that there's a dedicated package for this, so instead of just disabling
the mode on startup, let's prevent installation of the package.
#+begin_src emacs-lisp :tangle packages.el
(package! evil-escape :disable t)
#+end_src
** Gif-screencast
We can lazy load this using the start/stop commands.

I initially installed ~scrot~ for this, since it was the default capture program.
However it raised ~glib error: Saving to file ... failed~ each time it was run.
Google didn't reveal any easy fixed, so I switched to [[https://github.com/naelstrof/maim][maim]]. We now need to pass
it the window ID. This doesn't change throughout the lifetime of an emacs
instance, so as long as a single window is used ~xdotool getactivewindow~ will
give a satisfactory result.

It seems that when new colours appear, that tends to make ~gifsicle~ introduce
artefacts. To avoid this we pre-populate the colour map using the current doom
theme.
#+begin_src emacs-lisp
(use-package! gif-screencast
  :commands gif-screencast-mode
  :config
  (map! :map gif-screencast-mode-map
        :g "<f8>" #'gif-screencast-toggle-pause
        :g "<f9>" #'gif-screencast-stop)
  (setq gif-screencast-program "maim"
        gif-screencast-args `("--quality" "3" "-i" ,(string-trim-right
                                                     (shell-command-to-string
                                                      "xdotool getactivewindow")))
        gif-screencast-optimize-args '("--batch" "--optimize=3" "--usecolormap=/tmp/doom-color-theme"))
  (defun gif-screencast-write-colormap ()
    (f-write-text
     (replace-regexp-in-string
      "\n+" "\n"
      (mapconcat (lambda (c) (if (listp (cdr c))
                                 (cadr c))) doom-themes--colors "\n"))
     'utf-8
     "/tmp/doom-color-theme" ))
  (gif-screencast-write-colormap)
  (add-hook 'doom-load-theme-hook #'gif-screencast-write-colormap))
#+end_src
** Google-translate
#+begin_src emacs-lisp
(use-package! go-translate
  :defer t
  :init
  (setq
   gts-translate-list '(("en" "ru") ("ru" "en"))
   gts-buffer-follow-p t
   )
  (map!
   (:leader
    (:prefix-map ("o g" . "google")
     :desc "Open google-translator" "t" #'gts-do-translate)
    ))
  )
#+end_src
** Imenu
#+begin_src emacs-lisp
(use-package! imenu-list
  :defer t
  :init
  (setq
   imenu-list-position 'right
   ;; just a tad lower than the default
   imenu-list-size 0.25
   ;; That modeline is plain ugly. Treemacs & neotree don't have a modeline either.
   imenu-list-mode-line-format nil
   ;; imenu-list-auto-resize t
   imenu-list-auto-resize nil
   )
  (map!
   (:leader
    :desc "Toggle imenu-list" "oi" #'imenu-list-smart-toggle)
   :map imenu-list-major-mode-map
   :g "r"   #'imenu-list-refresh
   :g [tab] #'hs-toggle-hiding
   :n "gr"  #'imenu-list-refresh))
#+end_src
** Info colours
#+begin_src emacs-lisp
(use-package! info-colors
  :commands (info-colors-fontify-node))

(add-hook 'Info-selection-hook 'info-colors-fontify-node)

(add-hook 'Info-mode-hook #'mixed-pitch-mode)
#+end_src
# ** Ivy
# I prefer search matching to be ordered; it's more precise
# #+begin_src emacs-lisp
# (after! ivy
#   (add-to-list 'ivy-re-builders-alist '(counsel-projectile-find-file . ivy--regex-plus))
#   (setq +ivy-buffer-preview t))
# #+end_src

# While in an ivy mini-buffer =C-o= shows a list of all possible actions one may take.
# By default this is ~#'ivy-read-action-by-key~ however a better interface to this
# is using Hydra.
# #+begin_src emacs-lisp
# (setq ivy-read-action-function #'ivy-hydra-read-action)
# #+end_src
** Leetcode
It's nice to have leetcode in emacs
#+begin_src emacs-lisp :tangle packages.el
;; (package! leetcode)
#+end_src
#+begin_src emacs-lisp
;; (use-package! leetcode
;;   :config
;;   (setq leetcode-save-solutions t
;;         leetcode-directory "~/code/practice/leetcode"
;;         leetcode-prefer-sql "sqlite3")
;;   )
#+end_src
** Kdeconnect
#+begin_src emacs-lisp
(use-package! kdeconnect
  :config
  (setq kdeconnect-devices "2580ec370a27fbb7"))
#+end_src
** Keycast
let's just make sure this is lazy-loaded appropriately.
#+begin_src emacs-lisp
(use-package! keycast
  :commands keycast-mode
  :config
  (define-minor-mode keycast-mode
    "Show current command and its key binding in the mode line."
    :global t
    (if keycast-mode
        (progn
          (add-hook 'pre-command-hook 'keycast--update t)
          (add-to-list 'global-mode-string '("" mode-line-keycast " ")))
      (remove-hook 'pre-command-hook 'keycast--update)
      (setq global-mode-string (remove '("" mode-line-keycast " ") global-mode-string))))
  (custom-set-faces!
    '(keycast-command :inherit doom-modeline-debug
      :height 0.9)
    '(keycast-key :inherit custom-modified
      :height 1.1
      :weight bold)))
#+end_src
** Org Chef
Loading after org seems a bit premature. Let's just load it when we try to use
it, either by command or in a capture template.
#+begin_src emacs-lisp
(use-package! org-chef
  :commands (org-chef-insert-recipe org-chef-get-recipe-from-url))
#+end_src
** Reverse-im (Keyboard layouts)
#+begin_src emacs-lisp
;; Needed for `:after char-fold' to work
(use-package char-fold
  :custom
  (char-fold-symmetric t)
  (search-default-mode #'char-fold-to-regexp))

(use-package! reverse-im
  :ensure t
  :demand t
  :after char-fold ; but only after `char-fold' is loaded
  :bind
  ("M-T" . reverse-im-translate-word)
  :custom
  (reverse-im-avy-action-char nil)
  (reverse-im-input-methods '("russian-computer" "ukrainian-computer"))
  ;; That breaks avy
  ;; (reverse-im-read-char-advice-function #'reverse-im-read-char-exclude)
  (reverse-im-char-fold t)
  :config
  (reverse-im-mode t)
  )
#+end_src
** Which-key
Let's make this popup a bit faster
#+begin_src emacs-lisp
(setq which-key-idle-delay 0.5) ;; I need the help, I really do
#+end_src

I also think that having =evil-= appear in so many popups is a bit too verbose, let's change that, and do a few other similar tweaks while we're at it.
#+begin_src emacs-lisp
(setq which-key-allow-multiple-replacements t)
(after! which-key
  (pushnew!
   which-key-replacement-alist
   '(("" . "\\`+?evil[-:]?\\(?:a-\\)?\\(.*\\)") . (nil . "◂\\1"))
   '(("\\`g s" . "\\`evilem--?motion-\\(.*\\)") . (nil . "◃\\1"))
   ))
#+end_src
** Writeroom

#+begin_quote
From the =:ui zen= module.
#+end_quote

# For starters, I think Doom is a bit over-zealous when zooming in
# #+begin_src emacs-lisp
# (setq +zen-text-scale 1.2)
# #+end_src

Then, when using Org it would be nice to make a number of other aesthetic
tweaks. Namely:
+ Use a serifed variable-pitch font
+ Hiding headline leading stars
+ Using fleurons as headline bullets
+ Hiding line numbers
+ Removing outline indentation
+ Centring the text

#+begin_src emacs-lisp
(defvar +zen-serif-p t
  "Whether to use a serifed font with `mixed-pitch-mode'.")
(defvar +zen-org-starhide t
  "The value `org-modern-hide-stars' is set to.")

(after! writeroom-mode
  (defun +zen-prose-org-h ()
    "Reformat the current Org buffer appearance for prose."
    (when (eq major-mode 'org-mode)
      (setq display-line-numbers nil
            visual-fill-column-width 60
            )
      (when (featurep 'org-modern)
        (setq-local org-modern-star '("🙘" "🙙" "🙚" "🙛")
                    ;; org-modern-star '("🙐" "🙑" "🙒" "🙓" "🙔" "🙕" "🙖" "🙗")
                    org-modern-hide-stars +zen-org-starhide)
        (org-modern-mode -1)
        (org-modern-mode 1))
      (setq
       +zen--original-org-indent-mode-p org-indent-mode)
      ;; (org-indent-mode -1)
      ))
  (defun +zen-nonprose-org-h ()
    "Reverse the effect of `+zen-prose-org'."
    (when (eq major-mode 'org-mode)
      (when (bound-and-true-p org-modern-mode)
        (org-modern-mode -1)
        (org-modern-mode 1))
      (when +zen--original-org-indent-mode-p (org-indent-mode 1))))
  (pushnew! writeroom--local-variables
            'display-line-numbers
            'visual-fill-column-width
            'org-adapt-indentation
            'org-modern-mode
            'org-modern-star
            'org-modern-hide-stars)
  (add-hook 'writeroom-mode-enable-hook #'+zen-prose-org-h)
  (add-hook 'writeroom-mode-disable-hook #'+zen-nonprose-org-h))
#+end_src

** Wakatime
#+begin_src emacs-lisp
(use-package! wakatime-mode)
#+end_src
** YASnippet
Nested snippets are good, enable that.
#+begin_src emacs-lisp
(setq yas-triggers-in-field t)
#+end_src
** Fountain
#+begin_src emacs-lisp :tangle packages.el
(package! fountain-mode)
#+end_src

#+begin_src emacs-lisp
(use-package! fountain-mode)
#+end_src
** Open-With
#+begin_src emacs-lisp :tangle packages.el
(package! crux)
#+end_src

#+begin_src emacs-lisp
(use-package! crux
  :config
  (global-set-key (kbd "C-c o") #'crux-open-with)
  )
#+end_src
** Spray

Why not flash words on the screen. Why not --- hey, it could be fun.
#+begin_src emacs-lisp :tangle packages.el
(package! spray :pin "74d9dcfa2e8b38f96a43de9ab0eb13364300cb46")
#+end_src

It would be nice if Spray's default speed suited me better, and the keybindings
worked in evil mode. Let's do that and make the display slightly nicer while
we're at it.

#+begin_src emacs-lisp
(use-package! spray
  :commands spray-mode
  :config
  (setq spray-wpm 600
        spray-height 800)
  (defun spray-mode-hide-cursor ()
    "Hide or unhide the cursor as is appropriate."
    (if spray-mode
        (setq-local spray--last-evil-cursor-state evil-normal-state-cursor
                    evil-normal-state-cursor '(nil))
      (setq-local evil-normal-state-cursor spray--last-evil-cursor-state)))
  (add-hook 'spray-mode-hook #'spray-mode-hide-cursor)
  (map! :map spray-mode-map
        "<return>" #'spray-start/stop
        "f" #'spray-faster
        "s" #'spray-slower
        "t" #'spray-time
        "<right>" #'spray-forward-word
        "h" #'spray-forward-word
        "<left>" #'spray-backward-word
        "l" #'spray-backward-word
        "q" #'spray-quit))
#+end_src
** iscroll

Enable image scrolling

#+begin_src emacs-lisp
(use-package! iscroll
  :config
  (add-hook! 'org-mode-hook 'iscroll-mode)
  )
#+end_src
** Git blame
Visualize code authorship at a glance

#+begin_src emacs-lisp :tangle packages.el
(package! blamer :recipe (:host github :repo "artawower/blamer.el"))
#+end_src

#+begin_src emacs-lisp
(use-package! blamer
  :defer 20
  :custom
  (blamer-idle-time 0.3)
  (blamer-min-offset 70)
  :custom-face
  (blamer-face ((t :foreground "#7a88cf"
                   :background nil
                   :height 140
                   :italic t)))
  :init
  (map!
   (:leader
    :desc "Toggle authorship visualizer" "gT"
    (lambda () (interactive) (if  blamer-mode (blamer-mode 0) (blamer-mode 1)
                                  ))))
  :config
  (setq blamer-mode 0)
  ;;(global-blamer-mode 1)
  )
#+end_src
** Hydra
*** Pretty hydra
#+begin_src emacs-lisp
(use-package! pretty-hydra)
#+end_src
*** Hydra Posframe
#+begin_src emacs-lisp :tangle packages.el
(package! hydra-posframe :recipe (:host github :repo "Ladicle/hydra-posframe"))
#+end_src

#+begin_src emacs-lisp
(use-package! hydra-posframe
  :init
  ;; (setq hydra-posframe-poshandler 'posframe-poshandler-frame-bottom-center)
  (setq hydra-posframe-border-width 1)
  (setq hydra-posframe-parameters '((left-fringe . 10)(right-fringe . 10)))
  :config
  (when (display-graphic-p)
    (add-hook! 'after-init-hook 'hydra-posframe-enable)
    )
  )
#+end_src
*** Hydra's
**** Windows
Let's add hydra for window controls

#+begin_src emacs-lisp
(map!
 (:leader
  :desc "Open hydra for windows controls" "w/"
  #'+hydra/window-nav/body
  )
 )
#+end_src


#+begin_src emacs-lisp
;; (defhydra hydra-window (:color blue :hint nil)
;;             "
;;                                                                        ╭─────────┐
;;      Move to      Size    Scroll        Split                    Do    │ Windows │
;;   ╭────────────────────────────────────────────────────────────────────┴─────────╯
;;         ^_k_^           ^_K_^       ^_p_^    ╭─┬─┐^ ^        ╭─┬─┐^ ^         ↺ [_u_] undo layout
;;         ^^↑^^           ^^↑^^       ^^↑^^    │ │ │_v_ertical ├─┼─┤_b_alance   ↻ [_r_] restore layout
;;     _h_ ←   → _l_   _H_ ←   → _L_   ^^ ^^    ╰─┴─╯^ ^        ╰─┴─╯^ ^         ✗ [_d_] close window
;;         ^^↓^^           ^^↓^^       ^^↓^^    ╭───┐^ ^        ╭───┐^ ^         ⇋ [_w_] cycle window
;;         ^_j_^           ^_J_^       ^_n_^    ├───┤_s_tack    │   │_z_oom
;;         ^^ ^^           ^^ ^^       ^^ ^^    ╰───╯^ ^        ╰───╯^ ^
;;   --------------------------------------------------------------------------------
;;             "
;;   ("<tab>" hydra-master/body "back")
;;   ("<ESC>" nil "quit")
;;   ("n" joe-scroll-other-window :color red)
;;   ("p" joe-scroll-other-window-down :color red)
;;   ("b" balance-windows)
;;   ("d" delete-window)
;;   ("H" enlarge-window-horizontally :color red)
;;   ("h" windmove-left :color red)
;;   ("J" shrink-window :color red)
;;   ("j" windmove-down :color red)
;;   ("K" enlarge-window :color red)
;;   ("k" windmove-up :color red)
;;   ("L" shrink-window-horizontally :color red)
;;   ("l" windmove-right :color red)
;;   ("r" winner-redo :color red)
;;   ("s" split-window-vertically :color red)
;;   ("u" winner-undo :color red)
;;   ("v" split-window-horizontally :color red)
;;   ("w" other-window)
;;   ("z" delete-other-windows)
;;   )
#+end_src

**** Text zoom
Let's add hydra for zoom control

#+begin_src emacs-lisp
(map!
 (:leader
  :desc "Open hydra for zoom controls" "wz"
  #'+hydra/text-zoom/body
  )
 )
#+end_src

**** File info

Simple hydra for displaying and copying file information.

#+begin_src emacs-lisp :tangle packages.el
(package! file-info)
#+end_src
#+begin_src emacs-lisp
(use-package! file-info
  :ensure t
  :config
  (setq hydra-posframe-show-params
        `(:poshandler posframe-poshandler-frame-center
          :internal-border-width 2
          :left-fringe 16
          :right-fringe 16
          )
        )
  :init
  (map!
   (:leader
    :desc "Show file info" "fi"
    #'file-info-show
    )
   )
  )
#+end_src
**** Math hydra

Hidra for quickly inserting math symbols

#+begin_src emacs-lisp :tangle packages.el
(package! math-hydras
  :recipe (
           :host github
           :repo "ashok-khanna/math-hydras"
           :files ("math-hydras.el")
           )
  )
#+end_src
#+begin_src emacs-lisp
(provide 'math-hydras)
(use-package! math-hydras)
#+end_src
**** Dired hydra
#+begin_src emacs-lisp
(defhydra hydra-dired (:hint nil :color pink)
  "
_+_ mkdir          _v_iew           _m_ark             _(_ details        _i_nsert-subdir    wdired
_C_opy             _O_ view other   _U_nmark all       _)_ omit-mode      _$_ hide-subdir    C-x C-q : edit
_D_elete           _o_pen other     _u_nmark           _l_ redisplay      _w_ kill-subdir    C-c C-c : commit
_R_ename           _M_ chmod        _t_oggle           _g_ revert buf     _e_ ediff          C-c ESC : abort
_Y_ rel symlink    _G_ chgrp        _E_xtension mark   _s_ort             _=_ pdiff
_S_ymlink          ^ ^              _F_ind marked      _._ toggle hydra   \\ flyspell
_r_sync            ^ ^              ^ ^                ^ ^                _?_ summary
_z_ compress-file  _A_ find regexp
_Z_ compress       _Q_ repl regexp

T - tag prefix
"
  ("\\" dired-do-ispell)
  ("(" dired-hide-details-mode)
  (")" dired-omit-mode)
  ("+" dired-create-directory)
  ("=" diredp-ediff)         ;; smart diff
  ("?" dired-summary)
  ("$" diredp-hide-subdir-nomove)
  ("A" dired-do-find-regexp)
  ("C" dired-do-copy)        ;; Copy all marked files
  ("D" dired-do-delete)
  ("E" dired-mark-extension)
  ("e" dired-ediff-files)
  ("F" dired-do-find-marked-files)
  ("G" dired-do-chgrp)
  ("g" revert-buffer)        ;; read all directories again (refresh)
  ("i" dired-maybe-insert-subdir)
  ("l" dired-do-redisplay)   ;; relist the marked or singel directory
  ("M" dired-do-chmod)
  ("m" dired-mark)
  ("O" dired-display-file)
  ("o" dired-find-file-other-window)
  ("Q" dired-do-find-regexp-and-replace)
  ("R" dired-do-rename)
  ("r" dired-do-rsynch)
  ("S" dired-do-symlink)
  ("s" dired-sort-toggle-or-edit)
  ("t" dired-toggle-marks)
  ("U" dired-unmark-all-marks)
  ("u" dired-unmark)
  ("v" dired-view-file)      ;; q to exit, s to search, = gets line #
  ("w" dired-kill-subdir)
  ("Y" dired-do-relsymlink)
  ("z" diredp-compress-this-file)
  ("Z" dired-do-compress)
  ("q" nil)
  ("<ESC>" nil)
  ("." nil :color blue))

(map! :map dired-mode-map
      :ng "?" #'hydra-dired/body
      )
#+end_src

** Terminal Here

It's convenient to open terminals for current dir
#+begin_src emacs-lisp :tangle packages.el
(package! terminal-here)
#+end_src

#+begin_src emacs-lisp
(use-package! terminal-here
  :custom
  (terminal-here-linux-terminal-command 'alacritty)
  :init
  (map!
   (:leader
    :desc "Open folder with terminal" "ft"
    #'terminal-here-launch
    )
   (
    :leader
    :desc "Open folder with terminal" "fT"
    #'terminal-here-project-launch)
   )
  )
#+end_src
** Spell-fu

More dictionaries

#+begin_src emacs-lisp
(add-hook
 'spell-fu-mode-hook
 (lambda ()
   (spell-fu-dictionary-add (spell-fu-get-ispell-dictionary "uk"))
   (spell-fu-dictionary-add (spell-fu-get-ispell-dictionary "ru"))
   (spell-fu-dictionary-add (spell-fu-get-ispell-dictionary "en-computers"))
   (spell-fu-dictionary-add (spell-fu-get-ispell-dictionary "en-science"))
   ))
#+end_src

** Xresources-themes

#+begin_src emacs-lisp :tangle packages.el
(package! xresources-theme)
#+end_src
#+begin_src emacs-lisp
(use-package! xresources-theme)
#+end_src

* Applications
** Ebooks

For managing my ebooks, I'll hook into the well-established ebook library
manager [[https://calibre-ebook.com/][calibre]]. A number of Emacs clients for this exist, but this seems like a
good option.
#+begin_src emacs-lisp :tangle packages.el
(package! calibredb :pin "2f2cfc38f2d1c705134b692127c3008ac1382482")
#+end_src

Then for reading them, the only currently viable options seems to be [[https://depp.brause.cc/nov.el/][nov.el]].
#+begin_src emacs-lisp :tangle packages.el
(package! nov :pin "8f5b42e9d9f304b422c1a7918b43ee323a7d3532")
#+end_src

Together these should give me a rather good experience reading ebooks.

=calibredb= lets us use calibre through Emacs, because who wouldn't want to use
something through Emacs?
#+begin_src emacs-lisp
(use-package! calibredb
  :commands calibredb
  :config
  (setq calibredb-root-dir "~/Documents/books"
        calibredb-db-dir (expand-file-name "metadata.db" calibredb-root-dir))
  (map! :map calibredb-show-mode-map
        :ne "?" #'calibredb-entry-dispatch
        :ne "o" #'calibredb-find-file
        :ne "O" #'calibredb-find-file-other-frame
        :ne "V" #'calibredb-open-file-with-default-tool
        :ne "s" #'calibredb-set-metadata-dispatch
        :ne "e" #'calibredb-export-dispatch
        :ne "q" #'calibredb-entry-quit
        :ne "." #'calibredb-open-dired
        :ne [tab] #'calibredb-toggle-view-at-point
        :ne "M-t" #'calibredb-set-metadata--tags
        :ne "M-a" #'calibredb-set-metadata--author_sort
        :ne "M-A" #'calibredb-set-metadata--authors
        :ne "M-T" #'calibredb-set-metadata--title
        :ne "M-c" #'calibredb-set-metadata--comments)
  (map! :map calibredb-search-mode-map
        :ne [mouse-3] #'calibredb-search-mouse
        :ne "RET" #'calibredb-find-file
        :ne "?" #'calibredb-dispatch
        :ne "a" #'calibredb-add
        :ne "A" #'calibredb-add-dir
        :ne "c" #'calibredb-clone
        :ne "d" #'calibredb-remove
        :ne "D" #'calibredb-remove-marked-items
        :ne "j" #'calibredb-next-entry
        :ne "k" #'calibredb-previous-entry
        :ne "l" #'calibredb-virtual-library-list
        :ne "L" #'calibredb-library-list
        :ne "n" #'calibredb-virtual-library-next
        :ne "N" #'calibredb-library-next
        :ne "p" #'calibredb-virtual-library-previous
        :ne "P" #'calibredb-library-previous
        :ne "s" #'calibredb-set-metadata-dispatch
        :ne "S" #'calibredb-switch-library
        :ne "o" #'calibredb-find-file
        :ne "O" #'calibredb-find-file-other-frame
        :ne "v" #'calibredb-view
        :ne "V" #'calibredb-open-file-with-default-tool
        :ne "." #'calibredb-open-dired
        :ne "b" #'calibredb-catalog-bib-dispatch
        :ne "e" #'calibredb-export-dispatch
        :ne "r" #'calibredb-search-refresh-and-clear-filter
        :ne "R" #'calibredb-search-clear-filter
        :ne "q" #'calibredb-search-quit
        :ne "m" #'calibredb-mark-and-forward
        :ne "f" #'calibredb-toggle-favorite-at-point
        :ne "x" #'calibredb-toggle-archive-at-point
        :ne "h" #'calibredb-toggle-highlight-at-point
        :ne "u" #'calibredb-unmark-and-forward
        :ne "i" #'calibredb-edit-annotation
        :ne "DEL" #'calibredb-unmark-and-backward
        :ne [backtab] #'calibredb-toggle-view
        :ne [tab] #'calibredb-toggle-view-at-point
        :ne "M-n" #'calibredb-show-next-entry
        :ne "M-p" #'calibredb-show-previous-entry
        :ne "/" #'calibredb-search-live-filter
        :ne "M-t" #'calibredb-set-metadata--tags
        :ne "M-a" #'calibredb-set-metadata--author_sort
        :ne "M-A" #'calibredb-set-metadata--authors
        :ne "M-T" #'calibredb-set-metadata--title
        :ne "M-c" #'calibredb-set-metadata--comments))
#+end_src

Then, to actually read the ebooks we use =nov=.

#+begin_src emacs-lisp
(use-package! nov
  :mode ("\\.epub\\'" . nov-mode)
  :config
  (map! :map nov-mode-map
        :n "RET" #'nov-scroll-up)

  (defun doom-modeline-segment--nov-info ()
    (concat
     " "
     (propertize
      (cdr (assoc 'creator nov-metadata))
      'face 'doom-modeline-project-parent-dir)
     " "
     (cdr (assoc 'title nov-metadata))
     " "
     (propertize
      (format "%d/%d"
              (1+ nov-documents-index)
              (length nov-documents))
      'face 'doom-modeline-info)))

  (advice-add 'nov-render-title :override #'ignore)

  (defun +nov-mode-setup ()
    "Tweak nov-mode to our liking."
    (face-remap-add-relative 'variable-pitch
                             :family "Merriweather"
                             :height 1.4
                             :width 'semi-expanded)
    (face-remap-add-relative 'default :height 1.3)
    (setq-local line-spacing 0.2
                next-screen-context-lines 4
                shr-use-colors nil)
    (require 'visual-fill-column nil t)
    (setq-local visual-fill-column-center-text t
                visual-fill-column-width 81
                nov-text-width 80)
    (visual-fill-column-mode 1)
    (hl-line-mode -1)
    ;; Re-render with new display settings
    (nov-render-document)
    ;; Look up words with the dictionary.
    (add-to-list '+lookup-definition-functions #'+lookup/dictionary-definition)
    ;; Customise the mode-line to make it more minimal and relevant.
    (setq-local
     mode-line-format
     `((:eval
        (doom-modeline-segment--workspace-name))
       (:eval
        (doom-modeline-segment--window-number))
       (:eval
        (doom-modeline-segment--nov-info))
       ,(propertize
         " %P "
         'face 'doom-modeline-buffer-minor-mode)
       ,(propertize
         " "
         'face (if (doom-modeline--active) 'mode-line 'mode-line-inactive)
         'display `((space
                     :align-to
                     (- (+ right right-fringe right-margin)
                        ,(* (let ((width (doom-modeline--font-width)))
                              (or (and (= width 1) 1)
                                  (/ width (frame-char-width) 1.0)))
                            (string-width
                             (format-mode-line (cons "" '(:eval (doom-modeline-segment--major-mode))))))))))
       (:eval (doom-modeline-segment--major-mode)))))

  (add-hook 'nov-mode-hook #'+nov-mode-setup))
#+end_src
** File types
*** Systemd

For editing systemd unit files
#+begin_src emacs-lisp :tangle packages.el
(package! systemd :pin "b6ae63a236605b1c5e1069f7d3afe06ae32a7bae")
#+end_src

#+begin_src emacs-lisp
(use-package! systemd
  :defer t)
#+end_src
** Obsidian

It's nice to have some integration with obsidian in emacs

#+begin_src emacs-lisp :tangle packages.el
(package! obsidian)
#+end_src

#+begin_src emacs-lisp
(use-package obsidian
  :ensure t
  :demand t
  :config
  (obsidian-specify-path "~/Knowledge base")
  (global-obsidian-mode t)
  :bind (:map obsidian-mode-map
              ;; Replace C-c C-o with Obsidian.el's implementation. It's ok to use another key binding.
              ("C-c C-o" . obsidian-follow-link-at-point)
              ;; Jump to backlinks
              ("C-c C-b" . obsidian-backlink-jump)
              ;; If you prefer you can use `obsidian-insert-link'
              ("C-c C-l" . obsidian-insert-wikilink)))
#+end_src

* Language configuration
** Haskell
Set formatter
#+begin_src emacs-lisp
(after! lsp-haskell
  (setq lsp-haskell-formatting-provider "fourmolu"))
#+end_src

** Rust
Disable lsp formatter
#+begin_src emacs-lisp
(setq-hook! 'rustic-mode-hook +format-with-lsp nil)
#+end_src
** Js
Prefer prettier formatter.
#+begin_src emacs-lisp
(setq-hook! 'js2-mode-hook +format-with-lsp nil)
(setq-hook! 'typescript-mode-hook +format-with-lsp nil)
(setq-hook! 'typescript-tsx-mode-hook +format-with-lsp nil)
#+end_src

Show eslint help
#+begin_src emacs-lisp
(after! (:and lsp-mode flycheck-mode)
  (flycheck-add-next-checker 'lsp 'javascript-eslint))
#+end_src
** LaTeX
#+begin_src emacs-lisp
(setq TeX-save-query nil
      TeX-show-compilation t
      TeX-command-extra-options "-shell-escape")
(after! latex
  (add-to-list 'TeX-command-list '("XeLaTeX" "%`xelatex%(mode)%' %t" TeX-run-TeX nil t)))
#+end_src

Let's re-order the preferences.
#+begin_src emacs-lisp
(setq +latex-viewers '(zathura pdf-tools evince okular skim sumatrapdf))
#+end_src
** Markdown
Let's use mixed pitch, because it's great
#+begin_src emacs-lisp
(add-hook! (gfm-mode markdown-mode) #'mixed-pitch-mode)
#+end_src

Most of the time when I write markdown, it's going into some app/website which
will do it's own line wrapping, hence we /only/ want to use visual line wrapping. No hard stuff.
#+begin_src emacs-lisp
(add-hook! (gfm-mode markdown-mode) #'visual-line-mode #'turn-off-auto-fill)
#+end_src

Since markdown is often seen as rendered HTML, let's try to somewhat mirror the
style or markdown renderers.

Most markdown renders seem to make the first three headings levels larger than
normal text, the first two much so. Then the fourth level tends to be the same
as body text, while the fifth and sixth are (increasingly) smaller, with the
sixth greyed out. Since the sixth level is so small, I'll turn up the boldness a notch.
#+begin_src emacs-lisp
(custom-set-faces!
  '(markdown-header-face-1 :height 1.25 :weight extra-bold :inherit markdown-header-face)
  '(markdown-header-face-2 :height 1.15 :weight bold       :inherit markdown-header-face)
  '(markdown-header-face-3 :height 1.08 :weight bold       :inherit markdown-header-face)
  '(markdown-header-face-4 :height 1.00 :weight bold       :inherit markdown-header-face)
  '(markdown-header-face-5 :height 0.90 :weight bold       :inherit markdown-header-face)
  '(markdown-header-face-6 :height 0.75 :weight extra-bold :inherit markdown-header-face))
#+end_src
** Nix
Turn off company for nix
#+begin_src emacs-lisp
(setq-hook! 'nix-mode-hook company-idle-delay nil)
#+end_src

Use alejandra formatter
#+begin_src emacs-lisp
(set-formatter! 'alejandra "alejandra --quiet" :modes '(nix-mode))
#+end_src
** Org
:PROPERTIES:
:CUSTOM_ID: org
:header-args:emacs-lisp: :tangle no :noweb-ref org-conf
:END:

Finally, because this section is fairly expensive to initialise, we'll wrap it
in an src_elisp{(after! ...)} block.

#+begin_src emacs-lisp :noweb no-export :tangle yes :noweb-prefix no :noweb-ref nil
(after! org
  <<org-conf>>)
#+end_src

*** Behavior
**** Tweaking defaults
Some simple settings
#+begin_src emacs-lisp
(setq org-directory "~/org/"
      org-archive-location (concat org-directory ".archive/%s::")
      org-roam-directory (concat org-directory "notes/")
      org-journal-encrypt-journal t
      org-journal-file-format "%Y%m%d.org"
      )
(add-hook! org-mode :append
           #'org-fragtog-mode
           #'variable-pitch-mode
           )
#+end_src


#+begin_src emacs-lisp
(setq
 org-use-property-inheritance t              ; it's convenient to have properties inherited
 org-log-done 'time                          ; having the time a item is done sounds convininet
 org-list-allow-alphabetical t               ; have a. A. a) A) list bullets
 org-export-in-background t                  ; run export processes in external emacs process
 org-catch-invisible-edits 'smart            ; try not to accidently do weird stuff in invisible regions
 org-export-with-sub-superscripts '{}       ; don't treat lone _ / ^ as sub/superscripts, require _{} / ^{}
 )
#+end_src

I also like the ~:comments~ header-argument, so let's make that a default.
#+begin_src emacs-lisp
(setq org-babel-default-header-args
      '((:session . "none")
        (:results . "replace")
        (:exports . "code")
        (:cache . "no")
        (:noweb . "no")
        (:hlines . "no")
        (:tangle . "no")
        (:comments . "link")))
#+end_src

There also seem to be a few keybindings which use =hjkl=, but miss arrow key equivalents.
#+begin_src emacs-lisp
(map! :map evil-org-mode-map
      :after evil-org
      :n "g <up>" #'org-backward-heading-same-level
      :n "g <down>" #'org-forward-heading-same-level
      :n "g <left>" #'org-up-element
      :n "g <right>" #'org-down-element)
#+end_src
**** Latex snippets
#+begin_src emacs-lisp
(add-hook 'org-mode-hook
          (λ! (yas-minor-mode)
              (yas-activate-extra-mode 'latex-mode)))
#+end_src

**** Extra functionality
***** Org buffer creation
Let's also make creating an org buffer just that little bit easier.
#+begin_src emacs-lisp :tangle yes :noweb-ref none
(evil-define-command evil-buffer-org-new (count file)
  "Creates a new ORG buffer replacing the current window, optionally
   editing a certain FILE"
  :repeat nil
  (interactive "P<f>")
  (if file
      (evil-edit file)
    (let ((buffer (generate-new-buffer "*new org*")))
      (set-window-buffer nil buffer)
      (with-current-buffer buffer
        (org-mode)))))
(map! :leader
      (:prefix "b"
       :desc "New empty ORG buffer" "o" #'evil-buffer-org-new))
#+end_src
***** The utility of zero-width spaces
Occasionally in Org you run into annoyances where you want to have two seperate
blocks right together without a space. For example, to *emp​h*​asise part of a word,
or put a currency symbol immediately before an inline source block.
There is a solution to this, it just sounds slightly hacky --- zero width spaces.
Because this is Emacs, we can make this feel much less hacky by making a minor
addition to the Org key map 🙂.
#+begin_src emacs-lisp
(map! :map org-mode-map
      :nie "M-SPC M-SPC" (cmd! (insert "\u200B")))
#+end_src

We then want to stop the space from being included in exports, which can be done
with a little filter.
#+begin_src emacs-lisp
(defun +org-export-remove-zero-width-space (text _backend _info)
  "Remove zero width spaces from TEXT."
  (unless (org-export-derived-backend-p 'org)
    (replace-regexp-in-string "\u200B" "" text)))

(add-to-list 'org-export-filter-plain-text-functions #'+org-export-remove-zero-width-space t)
#+end_src
***** List bullet sequence
I think it makes sense to have list bullets change with depth
#+begin_src emacs-lisp
(setq org-list-demote-modify-bullet '(("+" . "-") ("-" . "+") ("*" . "+") ("1." . "a.")))
#+end_src
***** cdlatex
It's also nice to be able to use ~cdlatex~.
#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'turn-on-org-cdlatex)
#+end_src

It's handy to be able to quickly insert environments with =C-c }=. I almost always
want to edit them afterwards though, so let's make that happen by default.
#+begin_src emacs-lisp
(defadvice! org-edit-latex-emv-after-insert ()
  :after #'org-cdlatex-environment-indent
  (org-edit-latex-environment))
#+end_src

At some point in the future it could be good to investigate [[https://scripter.co/splitting-an-org-block-into-two/][splitting org blocks]].
Likewise [[https://archive.casouri.cat/note/2020/insert-math-symbol-in-emacs/][this]] looks good for symbols.
***** View exported file
='localeader v= has no pre-existing binding, so I may as well use it with the same
functionality as in LaTeX. Let's try viewing possible output files with this.
#+begin_src emacs-lisp
(map! :map org-mode-map
      :localleader
      :desc "View exported file" "v" #'org-view-output-file)

(defun org-view-output-file (&optional org-file-path)
  "Visit buffer open on the first output file (if any) found, using `org-view-output-file-extensions'"
  (interactive)
  (let* ((org-file-path (or org-file-path (buffer-file-name) ""))
         (dir (file-name-directory org-file-path))
         (basename (file-name-base org-file-path))
         (output-file nil))
    (dolist (ext org-view-output-file-extensions)
      (unless output-file
        (when (file-exists-p
               (concat dir basename "." ext))
          (setq output-file (concat dir basename "." ext)))))
    (if output-file
        (if (member (file-name-extension output-file) org-view-external-file-extensions)
            (browse-url-xdg-open output-file)
          (pop-to-buffer (or (find-buffer-visiting output-file)
                             (find-file-noselect output-file))))
      (message "No exported file found"))))

(defvar org-view-output-file-extensions '("pdf" "md" "rst" "txt" "tex" "html")
  "Search for output files with these extensions, in order, viewing the first that matches")
(defvar org-view-external-file-extensions '("html")
  "File formats that should be opened externally.")
#+end_src
***** Citation

#+begin_quote
Extending the =:tools biblio= module.
#+end_quote

References in Org are fairly easy now, thanks to =org-cite=. The =:tools biblio=
module gives a fairly decent basic setup, but it would be nice to take it a bit
further. This mostly consists of tweaking settings, but there is one extra
package I'll grab for prettier in-buffer citations.

#+begin_src emacs-lisp :noweb-ref none :tangle packages.el
(package! org-cite-csl-activate :recipe (:host github :repo "andras-simonyi/org-cite-csl-activate") :pin "9e68d9204469c674f49a20bdf7ea85da4f4bf720")
#+end_src

In particular, by setting ~org-cite-csl-activate-use-document-style~, we can have
the in-buffer displayed citations be the same as the exported form. Isn't that lovely!

Unfortunately, there's currently a potential for undesirable buffer
modifications, so we'll put all the activation code behind a function we can
call when we want it.

#+begin_src emacs-lisp
(use-package! oc-csl-activate
  :after oc
  :config
  (setq org-cite-csl-activate-use-document-style t
        org-cite-csl-activate-use-document-locale t
    )
  (defun +org-cite-csl-activate/enable ()
    (interactive)
    (setq org-cite-activate-processor 'csl-activate)
    (add-hook! 'org-mode-hook '((lambda () (cursor-sensor-mode 1)) org-cite-csl-activate-render-all))
    (defadvice! +org-cite-csl-activate-render-all-silent (orig-fn)
      :around #'org-cite-csl-activate-render-all
      (with-silent-modifications (funcall orig-fn)))
    (when (eq major-mode 'org-mode)
      (with-silent-modifications
        (save-excursion
          (goto-char (point-min))
          (org-cite-activate (point-max)))
        (org-cite-csl-activate-render-all)))
    (fmakunbound #'+org-cite-csl-activate/enable)))
#+end_src

Now that =oc-csl-activate= is set up, let's go ahead and customise some of the
packages already loaded. For starters, we can make use of the my Zotero files
with =citar=, and make the symbols a bit prettier.

#+begin_src emacs-lisp
(after! citar
  (setq org-cite-global-bibliography
        (let ((libfile-search-names '("library.json" "Library.json" "library.bib" "Library.bib"))
              (libfile-dir "~/Zotero")
              paths)
          (dolist (libfile libfile-search-names)
            (when (and (not paths)
                       (file-exists-p (expand-file-name libfile libfile-dir)))
              (setq paths (list (expand-file-name libfile libfile-dir)))))
          paths)
        citar-bibliography org-cite-global-bibliography
        citar-symbols
        `((file ,(all-the-icons-faicon "file-o" :face 'all-the-icons-green :v-adjust -0.1) . " ")
          (note ,(all-the-icons-material "speaker_notes" :face 'all-the-icons-blue :v-adjust -0.3) . " ")
          (link ,(all-the-icons-octicon "link" :face 'all-the-icons-orange :v-adjust 0.01) . " "))))
#+end_src

We can also make the Zotero CSL styles available to use.

#+begin_src emacs-lisp
(after! oc-csl
  (setq org-cite-csl-styles-dir "~/Zotero/styles"))
#+end_src

Since CSL works so nicely everywhere, we might as well use it as the default
citation export processor for everything.

#+begin_src emacs-lisp
(after! oc
  (setq org-cite-export-processors '((t csl))))
#+end_src

Then, for convenience we'll cap things off by putting the citation command under
Org's localleader.

#+begin_src emacs-lisp
(map! :after org
      :map org-mode-map
      :localleader
      :desc "Insert citation" "@" #'org-cite-insert)
#+end_src

Lastly, just in case I come across any old citations of mine, I think it would
be nice to have a function to convert =org-ref= citations to =org-cite= forms.

#+begin_src emacs-lisp
(after! oc
  (defun org-ref-to-org-cite ()
    "Attempt to convert org-ref citations to org-cite syntax."
    (interactive)
    (let* ((cite-conversions '(("cite" . "//b") ("Cite" . "//bc")
                               ("nocite" . "/n")
                               ("citep" . "") ("citep*" . "//f")
                               ("parencite" . "") ("Parencite" . "//c")
                               ("citeauthor" . "/a/f") ("citeauthor*" . "/a")
                               ("citeyear" . "/na/b")
                               ("Citep" . "//c") ("Citealp" . "//bc")
                               ("Citeauthor" . "/a/cf") ("Citeauthor*" . "/a/c")
                               ("autocite" . "") ("Autocite" . "//c")
                               ("notecite" . "/l/b") ("Notecite" . "/l/bc")
                               ("pnotecite" . "/l") ("Pnotecite" . "/l/bc")))
           (cite-regexp (rx (regexp (regexp-opt (mapcar #'car cite-conversions) t))
                            ":" (group (+ (not (any "\n 	,.)]}")))))))
      (save-excursion
        (goto-char (point-min))
        (while (re-search-forward cite-regexp nil t)
          (message (format "[cite%s:@%s]"
                                 (cdr (assoc (match-string 1) cite-conversions))
                                 (match-string 2)))
          (replace-match (format "[cite%s:@%s]"
                                 (cdr (assoc (match-string 1) cite-conversions))
                                 (match-string 2))))))))
#+end_src

#+begin_src emacs-lisp
(setq org-cite-csl-locales-dir "~/code/cloned/csl-locales")
#+end_src

**** Super agenda
#+begin_src emacs-lisp
(use-package! org-super-agenda
  :commands (org-super-agenda-mode))
(after! org-agenda
  (org-super-agenda-mode))

(setq org-agenda-skip-scheduled-if-done t
      org-agenda-skip-deadline-if-done t
      org-agenda-include-deadlines t
      org-agenda-block-separator nil
      org-agenda-tags-column 100 ;; from testing this seems to be a good value
      org-agenda-compact-blocks t)

(setq org-agenda-custom-commands
      '(("o" "Overview"
         ((agenda "" ((org-agenda-span 'day)
                      (org-super-agenda-groups
                       '((:name "Today"
                          :time-grid t
                          :date today
                          :todo "TODAY"
                          :scheduled today
                          :order 1)))))
          (alltodo "" ((org-agenda-overriding-header "")
                       (org-super-agenda-groups
                        '((:name "Next to do"
                           :todo "NEXT"
                           :order 1)
                          (:name "Work"
                           :tag "work"
                           :priority "A"
                           :order 3)
                          (:name "Important"
                           :tag "Important"
                           :priority "A"
                           :order 6)
                          (:name "Due Today"
                           :deadline today
                           :order 2)
                          (:name "Due Soon"
                           :deadline future
                           :order 8)
                          (:name "Overdue"
                           :deadline past
                           :face error
                           :order 7)
                          (:name "Assignments"
                           :tag "Assignment"
                           :order 10)
                          (:name "Issues"
                           :tag "Issue"
                           :order 12)
                          (:name "Emacs"
                           :tag "Emacs"
                           :order 13)
                          (:name "Projects"
                           :tag "Project"
                           :order 14)
                          (:name "Research"
                           :tag "Research"
                           :order 15)
                          (:name "To read"
                           :tag "Read"
                           :order 30)
                          (:name "To watch"
                           :tag "Watch"
                           :order 30)
                          (:name "Waiting"
                           :todo "WAITING"
                           :order 20)
                          (:name "University"
                           :tag "uni"
                           :order 32)
                          (:name "Trivial"
                           :priority<= "E"
                           :tag ("Trivial" "Unimportant")
                           :todo ("SOMEDAY" )
                           :order 90)
                          (:discard (:tag ("Chore" "Routine" "Daily")))))))))))
#+end_src
**** Snippet Helpers

I often want to set =src-block= headers, and it's a pain to
+ type them out
+ remember what the accepted values are
+ oh, and specifying the same language again and again

We can solve this in three steps
+ having one-letter snippets, conditioned on ~(point)~ being within a src header
+ creating a nice prompt showing accepted values and the current default
+ pre-filling the =src-block= language with the last language used

For header args, the keys I'll use are
+ =r= for =:results=
+ =e= for =:exports=
+ =v= for =:eval=
+ =s= for =:session=
+ =d= for =:dir=

#+begin_src emacs-lisp
(defun +yas/org-src-header-p ()
  "Determine whether `point' is within a src-block header or header-args."
  (pcase (org-element-type (org-element-context))
    ('src-block (< (point) ; before code part of the src-block
                   (save-excursion (goto-char (org-element-property :begin (org-element-context)))
                                   (forward-line 1)
                                   (point))))
    ('inline-src-block (< (point) ; before code part of the inline-src-block
                          (save-excursion (goto-char (org-element-property :begin (org-element-context)))
                                          (search-forward "]{")
                                          (point))))
    ('keyword (string-match-p "^header-args" (org-element-property :value (org-element-context))))))
#+end_src

Now let's write a function we can reference in yasnippets to produce a nice
interactive way to specify header args.

#+begin_src emacs-lisp
(defun +yas/org-prompt-header-arg (arg question values)
  "Prompt the user to set ARG header property to one of VALUES with QUESTION.
The default value is identified and indicated. If either default is selected,
or no selection is made: nil is returned."
  (let* ((src-block-p (not (looking-back "^#\\+property:[ \t]+header-args:.*" (line-beginning-position))))
         (default
           (or
            (cdr (assoc arg
                        (if src-block-p
                            (nth 2 (org-babel-get-src-block-info t))
                          (org-babel-merge-params
                           org-babel-default-header-args
                           (let ((lang-headers
                                  (intern (concat "org-babel-default-header-args:"
                                                  (+yas/org-src-lang)))))
                             (when (boundp lang-headers) (eval lang-headers t)))))))
            ""))
         default-value)
    (setq values (mapcar
                  (lambda (value)
                    (if (string-match-p (regexp-quote value) default)
                        (setq default-value
                              (concat value " "
                                      (propertize "(default)" 'face 'font-lock-doc-face)))
                      value))
                  values))
    (let ((selection (consult--read values :prompt question :default default-value)))
      (unless (or (string-match-p "(default)$" selection)
                  (string= "" selection))
        selection))))
#+end_src

Finally, we fetch the language information for new source blocks.

Since we're getting this info, we might as well go a step further and also
provide the ability to determine the most popular language in the buffer that
doesn't have any =header-args= set for it (with =#+properties=).

#+begin_src emacs-lisp
(defun +yas/org-src-lang ()
  "Try to find the current language of the src/header at `point'.
Return nil otherwise."
  (let ((context (org-element-context)))
    (pcase (org-element-type context)
      ('src-block (org-element-property :language context))
      ('inline-src-block (org-element-property :language context))
      ('keyword (when (string-match "^header-args:\\([^ ]+\\)" (org-element-property :value context))
                  (match-string 1 (org-element-property :value context)))))))

(defun +yas/org-last-src-lang ()
  "Return the language of the last src-block, if it exists."
  (save-excursion
    (beginning-of-line)
    (when (re-search-backward "^[ \t]*#\\+begin_src" nil t)
      (org-element-property :language (org-element-context)))))

(defun +yas/org-most-common-no-property-lang ()
  "Find the lang with the most source blocks that has no global header-args, else nil."
  (let (src-langs header-langs)
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "^[ \t]*#\\+begin_src" nil t)
        (push (+yas/org-src-lang) src-langs))
      (goto-char (point-min))
      (while (re-search-forward "^[ \t]*#\\+property: +header-args" nil t)
        (push (+yas/org-src-lang) header-langs)))

    (setq src-langs
          (mapcar #'car
                  ;; sort alist by frequency (desc.)
                  (sort
                   ;; generate alist with form (value . frequency)
                   (cl-loop for (n . m) in (seq-group-by #'identity src-langs)
                            collect (cons n (length m)))
                   (lambda (a b) (> (cdr a) (cdr b))))))

    (car (cl-set-difference src-langs header-langs :test #'string=))))
#+end_src

**** Translate capital keywords (old) to lower case (new)
Everyone used to use ~#+CAPITAL~ keywords. Then people realised that ~#+lowercase~
is actually both marginally easier and visually nicer, so now the capital
version is just used in the manual.
#+begin_quote
Org is standardized on lower case. Uppercase is used in the manual as a poor
man's bold, and supported for historical reasons. --- [[https://orgmode.org/list/87tuuw3n15.fsf@nicolasgoaziou.fr][Nicolas Goaziou on the Org ML]]
#+end_quote

To avoid sometimes having to choose between the hassle out of updating old
documents and using mixed syntax, I'll whip up a basic transcode-y function.
It likely misses some edge cases, but should mostly work.

#+begin_src emacs-lisp
(defun org-syntax-convert-keyword-case-to-lower ()
  "Convert all #+KEYWORDS to #+keywords."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (let ((count 0)
          (case-fold-search nil))
      (while (re-search-forward "^[ \t]*#\\+[A-Z_]+" nil t)
        (unless (s-matches-p "RESULTS" (match-string 0))
          (replace-match (downcase (match-string 0)) t)
          (setq count (1+ count))))
      (message "Replaced %d occurances" count))))
#+end_src
**** Fix problematic hooks
When one of the src_elisp{org-mode-hook} functions errors, it halts the hook
execution. This is problematic, and there are two hooks in particular which
cause issues. Let's make their failure less eventful.

#+begin_src emacs-lisp
(defadvice! shut-up-org-problematic-hooks (orig-fn &rest args)
  :around #'org-fancy-priorities-mode
  (ignore-errors (apply orig-fn args)))
#+end_src
**** Mermaid diagrams
Diagram can be generated using something like this

#+BEGIN_EXAMPLE
#+begin_src mermaid :file test.png
sequenceDiagram
 A-->B: Works!
#+end_src
#+END_EXAMPLE

#+begin_src emacs-lisp
(use-package! ob-mermaid
  :config
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((mermaid . t)))
  ;; (setq ob-mermaid-cli-path (executable-find "mmdc"))
  )
#+end_src
**** Org-roam
Add ui for org-roam

#+begin_src emacs-lisp
(use-package! websocket
  :after org-roam)

(use-package! org-roam-ui
  :after org-roam
  :config
  (setq org-roam-ui-sync-theme t
        org-roam-ui-follow t
        org-roam-ui-update-on-save t
        org-roam-ui-open-on-start t))
#+end_src
**** Org-transclusion
#+begin_src emacs-lisp
(use-package! org-transclusion
  :after org
  :init
  (map!
   :map global-map "<f12>" #'org-transclusion-add
   :leader
   :prefix "n"
   :desc "Org Transclusion Mode" "t" #'org-transclusion-mode))
#+end_src
**** Org media notes
Let's have media notes in org-mode

#+begin_src emacs-lisp
(use-package! org-media-note
  :init (setq org-media-note-use-org-ref t)
  :hook (org-mode .  org-media-note-mode)
  :bind (
         ("H-v" . org-media-note-hydra/body))
  :config
  (setq org-media-note-screenshot-image-dir org-attach-id-dir)  ;; Folder to save screenshot
  (setq org-media-note-use-refcite-first t)
  )
#+end_src
*** Visuals
**** Org Modern

Fontifying =org-mode= buffers to be as pretty as possible is of paramount importance,
and Minad's lovely =org-modern= goes a long way in this regard.

# #+begin_src emacs-lisp :tangle packages.el
# (package! org-modern :pin "537e6b75e38bc0eff083c390c257098c9fc9ab49")
# #+end_src

...with a touch of configuration...

#+begin_src emacs-lisp :tangle yes
(use-package! org-modern
  :hook (org-mode . org-modern-mode)
  :config
  (setq
   ;; org-modern-star '("◉" "○" "✸" "✿" "✤" "✜" "◆" "▶")
   org-modern-table-vertical 1
   org-modern-table-horizontal 0.2
   org-modern-todo-faces
   '(("TODO" :inverse-video t :inherit org-todo)
     ("PROJ" :inverse-video t :inherit +org-todo-project)
     ("STRT" :inverse-video t :inherit +org-todo-active)
     ("[-]"  :inverse-video t :inherit +org-todo-active)
     ("HOLD" :inverse-video t :inherit +org-todo-onhold)
     ("WAIT" :inverse-video t :inherit +org-todo-onhold)
     ("[?]"  :inverse-video t :inherit +org-todo-onhold)
     ("KILL" :inverse-video t :inherit +org-todo-cancel)
     ("NO"   :inverse-video t :inherit +org-todo-cancel))
   org-modern-footnote
   (cons nil (cadr org-script-display))
   org-modern-block-fringe t
   org-modern-block-name
   '((t . t)
     ("src" "»" "«")
     ("example" "»–" "–«")
     ("quote" "❝" "❞")
     ("export" "⏩" "⏪"))
   org-modern-progress nil
   org-modern-priority nil
   org-modern-horizontal-rule (make-string 36 ?─)
   org-modern-keyword
   '((t . t)
     ("title" . "𝙏")
     ("subtitle" . "𝙩")
     ("author" . "𝘼")
     ("email" . #("" 0 1 (display (raise -0.14))))
     ("date" . "𝘿")
     ("property" . "☸")
     ("options" . "⌥")
     ("startup" . "⏻")
     ("macro" . "𝓜")
     ("bind" . #("" 0 1 (display (raise -0.1))))
     ("bibliography" . "")
     ("print_bibliography" . #("" 0 1 (display (raise -0.1))))
     ("cite_export" . "⮭")
     ("print_glossary" . #("ᴬᶻ" 0 1 (display (raise -0.1))))
     ("glossary_sources" . #("" 0 1 (display (raise -0.14))))
     ("include" . "⇤")
     ("setupfile" . "⇚")
     ("html_head" . "🅷")
     ("html" . "🅗")
     ("latex_class" . "🄻")
     ("latex_class_options" . #("🄻" 1 2 (display (raise -0.14))))
     ("latex_header" . "🅻")
     ("latex_header_extra" . "🅻⁺")
     ("latex" . "🅛")
     ("beamer_theme" . "🄱")
     ("beamer_color_theme" . #("🄱" 1 2 (display (raise -0.12))))
     ("beamer_font_theme" . "🄱𝐀")
     ("beamer_header" . "🅱")
     ("beamer" . "🅑")
     ("attr_latex" . "🄛")
     ("attr_html" . "🄗")
     ("attr_org" . "⒪")
     ("call" . #("" 0 1 (display (raise -0.15))))
     ("name" . "⁍")
     ("header" . "›")
     ("caption" . "☰")
     ("RESULTS" . "🠶")))
  (custom-set-faces! '(org-modern-statistics :inherit org-checkbox-statistics-todo)))
#+end_src

Since =org-modern='s tag face supplants Org's tag face, we need to adjust the
spell-check face ignore list

#+begin_src emacs-lisp
(after! spell-fu
  (cl-pushnew 'org-modern-tag (alist-get 'org-mode +spell-excluded-faces-alist)))
#+end_src

**** Emphasis markers

While ~org-hide-emphasis-markers~ is very nice, it can sometimes make edits which
occur at the border a bit more fiddley. We can improve this situation without
sacrificing visual amenities with the =org-appear= package.

# #+begin_src emacs-lisp :tangle packages.el
# (package! org-appear :recipe (:host github :repo "awth13/org-appear")
#   :pin "60ba267c5da336e75e603f8c7ab3f44e6f4e4dac")
# #+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! org-appear
  :hook (org-mode . org-appear-mode)
  :config
  (setq org-appear-autoemphasis t
        org-appear-autosubmarkers t
        org-appear-autolinks nil)
  ;; for proper first-time setup, `org-appear--set-elements'
  ;; needs to be run after other hooks have acted.
  (run-at-time nil nil #'org-appear--set-elements))
#+end_src

**** Font Display
Mixed pitch is great. As is ~+org-pretty-mode~, let's use them.
#+begin_src emacs-lisp
(add-hook! 'org-mode-hook #'+org-pretty-mode #'mixed-pitch-mode)
#+end_src

Let's make headings a bit bigger
#+begin_src emacs-lisp
(custom-set-faces!
  '(outline-1 :weight extra-bold :height 1.25)
  '(outline-2 :weight bold :height 1.15)
  '(outline-3 :weight bold :height 1.12)
  '(outline-4 :weight semi-bold :height 1.09)
  '(outline-5 :weight semi-bold :height 1.06)
  '(outline-6 :weight semi-bold :height 1.03)
  '(outline-8 :weight semi-bold)
  '(outline-9 :weight semi-bold))
#+end_src

And the same with the title.
#+begin_src emacs-lisp
(custom-set-faces!
  '(org-document-title :height 1.2))
#+end_src

It seems reasonable to have deadlines in the error face when they're passed.
#+begin_src emacs-lisp
(setq org-agenda-deadline-faces
      '((1.001 . error)
        (1.0 . org-warning)
        (0.5 . org-upcoming-deadline)
        (0.0 . org-upcoming-distant-deadline)))
#+end_src

We can then have quote blocks stand out a bit more by making them /italic/.
#+begin_src emacs-lisp
(setq org-fontify-quote-and-verse-blocks t)
#+end_src

While ~org-hide-emphasis-markers~ is very nice, it can sometimes make edits which
occur at the border a bit more fiddley. We can improve this situation without
sacrificing visual amenities with the =org-appear= package.
#+begin_src emacs-lisp
(use-package! org-appear
  :hook (org-mode . org-appear-mode)
  :config
  (setq org-appear-autoemphasis t
        org-appear-autosubmarkers t
        org-appear-autolinks nil)
  ;; for proper first-time setup, `org-appear--set-elements'
  ;; needs to be run after other hooks have acted.
  (run-at-time nil nil #'org-appear--set-elements))
#+end_src

Org files can be rather nice to look at, particularly with some of the
customisations here. This comes at a cost however, expensive font-lock.
Feeling like you're typing through molasses in large files is no fun, but there
is a way I can defer font-locking when typing to make the experience more
responsive.
#+begin_src emacs-lisp
(defun locally-defer-font-lock ()
  "Set jit-lock defer and stealth, when buffer is over a certain size."
  (when (> (buffer-size) 50000)
    (setq-local jit-lock-defer-time 0.05
                jit-lock-stealth-time 1)))

(add-hook 'org-mode-hook #'locally-defer-font-lock)
#+end_src
Apparently this causes issues with some people, but I haven't noticed anything
problematic beyond the expected slight delay in some fontification, so until I
do I'll use the above.

**** Reduced text indent

Thanks to the various bits and bobs of setup we have here, the non-heading lines
tend to appear over-indented in ~org-indent-mode~. We can adjust this by modifying
the generated text prefixes.

There's another issue we can have when using mixed-pitch mode, where the line
height is set by the indent prefix displayed with the fixed-pitch font. This
means that on 0-indent lines the line spacing can be different, which doesn't
look very good. We can also solve this problem by modifying the generated text
prefixes to but a fixed-pitch zero width space at the start of 0-indent lines
instead of nothing.

#+begin_src emacs-lisp
(defadvice! +org-indent--reduced-text-prefixes ()
  :after #'org-indent--compute-prefixes
  (setq org-indent--text-line-prefixes
        (make-vector org-indent--deepest-level nil))
  (when (> org-indent-indentation-per-level 0)
    (dotimes (n org-indent--deepest-level)
      (aset org-indent--text-line-prefixes
            n
            (org-add-props
                (concat (make-string (* n (1- org-indent-indentation-per-level))
                                     ?\s)
                        (if (> n 0)
                             (char-to-string org-indent-boundary-char)
                          "\u200b"))
                nil 'face 'org-indent)))))
#+end_src

**** Fontifying inline src blocks
Org does lovely things with =#+begin_src= blocks, like using font-lock for
language's major-mode behind the scenes and pulling out the lovely colourful
results. By contrast, inline =src_= blocks are somewhat neglected.

I am not the first person to feel this way, thankfully others have [[https://stackoverflow.com/questions/20309842/how-to-syntax-highlight-for-org-mode-inline-source-code-src-lang/28059832][taken to
stackexchange]] to voice their desire for inline src fontification. I was going to
steal their work, but unfortunately they didn't perform /true/ source code
fontification, but simply applied the =org-code= face to the content.

We can do better than that, and we shall! Using ~org-src-font-lock-fontify-block~
we can apply language-appropriate syntax highlighting. Then, continuing on to
={{{results(...)}}}= , it can have the =org-block= face applied to match, and then
the value-surrounding constructs hidden by mimicking the behaviour of
~prettify-symbols-mode~.

#+begin_warning
This currently only highlights a single inline src block per line.
I have no idea why it stops, but I'd rather it didn't.
If you have any idea what's going on or how to fix this /please/ get in touch.
#+end_warning

#+begin_src emacs-lisp
(defvar org-prettify-inline-results t
  "Whether to use (ab)use prettify-symbols-mode on {{{results(...)}}}.
Either t or a cons cell of strings which are used as substitutions
for the start and end of inline results, respectively.")

(defvar org-fontify-inline-src-blocks-max-length 200
  "Maximum content length of an inline src block that will be fontified.")

(defun org-fontify-inline-src-blocks (limit)
  "Try to apply `org-fontify-inline-src-blocks-1'."
  (condition-case nil
      (org-fontify-inline-src-blocks-1 limit)
    (error (message "Org mode fontification error in %S at %d"
                    (current-buffer)
                    (line-number-at-pos)))))

(defun org-fontify-inline-src-blocks-1 (limit)
  "Fontify inline src_LANG blocks, from `point' up to LIMIT."
  (let ((case-fold-search t)
        (initial-point (point)))
    (while (re-search-forward "\\_<src_\\([^ \t\n[{]+\\)[{[]?" limit t) ; stolen from `org-element-inline-src-block-parser'
      (let ((beg (match-beginning 0))
            pt
            (lang-beg (match-beginning 1))
            (lang-end (match-end 1)))
        (remove-text-properties beg lang-end '(face nil))
        (font-lock-append-text-property lang-beg lang-end 'face 'org-meta-line)
        (font-lock-append-text-property beg lang-beg 'face 'shadow)
        (font-lock-append-text-property beg lang-end 'face 'org-block)
        (setq pt (goto-char lang-end))
        ;; `org-element--parse-paired-brackets' doesn't take a limit, so to
        ;; prevent it searching the entire rest of the buffer we temporarily
        ;; narrow the active region.
        (save-restriction
          (narrow-to-region beg (min (point-max) limit (+ lang-end org-fontify-inline-src-blocks-max-length)))
          (when (ignore-errors (org-element--parse-paired-brackets ?\[))
            (remove-text-properties pt (point) '(face nil))
            (font-lock-append-text-property pt (point) 'face 'org-block)
            (setq pt (point)))
          (when (ignore-errors (org-element--parse-paired-brackets ?\{))
            (remove-text-properties pt (point) '(face nil))
            (font-lock-append-text-property pt (1+ pt) 'face '(org-block shadow))
            (unless (= (1+ pt) (1- (point)))
              (if org-src-fontify-natively
                  (org-src-font-lock-fontify-block (buffer-substring-no-properties lang-beg lang-end) (1+ pt) (1- (point)))
                (font-lock-append-text-property (1+ pt) (1- (point)) 'face 'org-block)))
            (font-lock-append-text-property (1- (point)) (point) 'face '(org-block shadow))
            (setq pt (point))))
        (when (and org-prettify-inline-results (re-search-forward "\\= {{{results(" limit t))
          (font-lock-append-text-property pt (1+ pt) 'face 'org-block)
          (goto-char pt))))
    (when org-prettify-inline-results
      (goto-char initial-point)
      (org-fontify-inline-src-results limit))))

(defun org-fontify-inline-src-results (limit)
  (while (re-search-forward "{{{results(\\(.+?\\))}}}" limit t)
    (remove-list-of-text-properties (match-beginning 0) (point)
                                    '(composition
                                      prettify-symbols-start
                                      prettify-symbols-end))
    (font-lock-append-text-property (match-beginning 0) (match-end 0) 'face 'org-block)
    (let ((start (match-beginning 0)) (end (match-beginning 1)))
      (with-silent-modifications
        (compose-region start end (if (eq org-prettify-inline-results t) "⟨" (car org-prettify-inline-results)))
        (add-text-properties start end `(prettify-symbols-start ,start prettify-symbols-end ,end))))
    (let ((start (match-end 1)) (end (point)))
      (with-silent-modifications
        (compose-region start end (if (eq org-prettify-inline-results t) "⟩" (cdr org-prettify-inline-results)))
        (add-text-properties start end `(prettify-symbols-start ,start prettify-symbols-end ,end))))))

(defun org-fontify-inline-src-blocks-enable ()
  "Add inline src fontification to font-lock in Org.
Must be run as part of `org-font-lock-set-keywords-hook'."
  (setq org-font-lock-extra-keywords
        (append org-font-lock-extra-keywords '((org-fontify-inline-src-blocks)))))

(add-hook 'org-font-lock-set-keywords-hook #'org-fontify-inline-src-blocks-enable)
#+end_src

**** Symbols
It's also nice to change the character used for collapsed items (by default ~…~),
I think ~▾~ is better for indicating 'collapsed section'.
and add an extra ~org-bullet~ to the default list of four.
I've also added some fun alternatives, just commented out.
#+begin_src emacs-lisp
;; (use-package org-pretty-tags
;; :config
;;  (setq org-pretty-tags-surrogate-strings
;;        `(("uni"        . ,(all-the-icons-faicon   "graduation-cap" :face 'all-the-icons-purple  :v-adjust 0.01))
;;          ("ucc"        . ,(all-the-icons-material "computer"       :face 'all-the-icons-silver  :v-adjust 0.01))
;;          ("assignment" . ,(all-the-icons-material "library_books"  :face 'all-the-icons-orange  :v-adjust 0.01))
;;          ("test"       . ,(all-the-icons-material "timer"          :face 'all-the-icons-red     :v-adjust 0.01))
;;          ("lecture"    . ,(all-the-icons-fileicon "keynote"        :face 'all-the-icons-orange  :v-adjust 0.01))
;;          ("email"      . ,(all-the-icons-faicon   "envelope"       :face 'all-the-icons-blue    :v-adjust 0.01))
;;          ("read"       . ,(all-the-icons-octicon  "book"           :face 'all-the-icons-lblue   :v-adjust 0.01))
;;          ("article"    . ,(all-the-icons-octicon  "file-text"      :face 'all-the-icons-yellow  :v-adjust 0.01))
;;          ("web"        . ,(all-the-icons-faicon   "globe"          :face 'all-the-icons-green   :v-adjust 0.01))
;;          ("info"       . ,(all-the-icons-faicon   "info-circle"    :face 'all-the-icons-blue    :v-adjust 0.01))
;;          ("issue"      . ,(all-the-icons-faicon   "bug"            :face 'all-the-icons-red     :v-adjust 0.01))
;;          ("someday"    . ,(all-the-icons-faicon   "calendar-o"     :face 'all-the-icons-cyan    :v-adjust 0.01))
;;          ("idea"       . ,(all-the-icons-octicon  "light-bulb"     :face 'all-the-icons-yellow  :v-adjust 0.01))
;;          ("emacs"      . ,(all-the-icons-fileicon "emacs"          :face 'all-the-icons-lpurple :v-adjust 0.01))))
;;  (org-pretty-tags-global-mode))

(after! org-superstar
  (setq ;; org-superstar-headline-bullets-list '("◉" "○" "✸" "✿" "✤" "✜" "◆" "▶")
        ;; org-superstar-headline-bullets-list '("Ⅰ" "Ⅱ" "Ⅲ" "Ⅳ" "Ⅴ" "Ⅵ" "Ⅶ" "Ⅷ" "Ⅸ" "Ⅹ")
        org-superstar-prettify-item-bullets t ))

(setq org-ellipsis " ▾ "
      org-hide-leading-stars t
      org-priority-highest ?A
      org-priority-lowest ?E
      org-priority-faces
      '((?A . 'all-the-icons-red)
        (?B . 'all-the-icons-orange)
        (?C . 'all-the-icons-yellow)
        (?D . 'all-the-icons-green)
        (?E . 'all-the-icons-blue)))
#+end_src
It's also nice to make use of the Unicode characters for check boxes, and other commands.
#+begin_src emacs-lisp
(appendq! +ligatures-extra-symbols
          (list
           :list_property "∷"
           :em_dash       "—"
           :ellipses      "…"
           :arrow_right   "→"
           :arrow_left    "←"
           ;; :title         "𝙏"
           ;; :subtitle      "𝙩"
           ;; :author        "𝘼"
           ;; :date          "𝘿"
           ;; :latex_class   "🄲"
           ;; :attr_latex    "🄛"
           ;; :attr_html     "🄗"
           ;; :begin_quote   "❝"
           ;; :end_quote     "❞"
           ;; :caption       "☰"
           ;; :header        "›"
           ;; :bibliography  ""
           ;; :print_biblio  ""
           )
          )

(defadvice! +org-init-appearance-h--no-ligatures-a ()
  :after #'+org-init-appearance-h
  (set-ligatures! 'org-mode nil)
  (set-ligatures! 'org-mode
    :list_property "::"
    :em_dash       "---"
    :ellipsis      "..."
    :arrow_right   "->"
    :arrow_left    "<-"
    :arrow_lr      "<->"
    :properties    ":PROPERTIES:"
    :end           ":END:"
    :priority_a    "[#A]"
    :priority_b    "[#B]"
    :priority_c    "[#C]"
    :priority_d    "[#D]"
    :priority_e    "[#E]"))

;; (set-ligatures! 'org-mode
;;   :merge t
;;   :list_property "::"
;;   :em_dash       "---"
;;   :ellipsis      "..."
;;   :arrow_right   "->"
;;   :arrow_left    "<-"
;;   ;; :title         "#+title:"
;;   ;; :subtitle      "#+subtitle:"
;;   ;; :author        "#+author:"
;;   ;; :date          "#+date:"
;;   ;; :latex_class   "#+latex_class:"
;;   ;; :attr_latex    "#+attr_latex:"
;;   ;; :attr_html     "#+attr_html:"
;;   ;; :begin_quote   "#+begin_quote"
;;   ;; :end_quote     "#+end_quote"
;;   ;; :caption       "#+caption:"
;;   ;; :header        "#+header:"
;;   ;; :bibliography  "#+bibliography:"
;;   ;; :print-biblio  "#+print_bibliography:"
;;   )
;; (plist-put +ligatures-extra-symbols :name "⁍")
#+end_src

**** LaTeX Fragments
***** Prettier highlighting

First off, we want those fragments to look good.
#+begin_src emacs-lisp
(setq org-highlight-latex-and-related '(native script entities))
#+end_src

However, by using =native= highlighting the =org-block= face is added, and that
doesn't look too great --- particularly when the fragments are previewed.

Ideally ~org-src-font-lock-fontify-block~ wouldn't add the =org-block= face, but we
can avoid advising that entire function by just adding another face with
=:inherit default= which will override the background colour.

Inspecting ~org-do-latex-and-related~ shows that ="latex"= is the language argument
passed, and so we can override the background as discussed above.
#+begin_src emacs-lisp
(require 'org-src)
(add-to-list 'org-src-block-faces '("latex" (:inherit default :extend t)))
#+end_src

***** More eager rendering
What's better than syntax-highlighted LaTeX is /rendered/ LaTeX though, and we can
have this be performed automatically with =org-fragtog=.
#+begin_src emacs-lisp
(use-package! org-fragtog
  :hook (org-mode . org-fragtog-mode))
#+end_src
***** Prettier rendering
Since we can, instead of making the background colour match the =default= face,
let's make it transparent.
#+begin_src emacs-lisp
(setq org-format-latex-options
      (plist-put org-format-latex-options :background "Transparent"))
#+end_src
***** Fixes for lualatex
#+begin_src emacs-lisp
(setq org-preview-latex-default-process 'dvisvgm)
(setq org-preview-latex-process-alist
       '((dvipng :programs
         ("lualatex" "dvipng")
         :description "dvi > png" :message "you need to install the programs: latex and dvipng." :image-input-type "dvi" :image-output-type "png" :image-size-adjust
         (1.0 . 1.0)
         :latex-compiler
         ("lualatex -output-format dvi -interaction nonstopmode -output-directory %o %f")
         :image-converter
         ("dvipng -fg %F -bg %B -D %D -T tight -o %O %f"))
       (dvisvgm :programs
          ("latex" "dvisvgm")
          :description "dvi > svg" :message "you need to install the programs: latex and dvisvgm." :use-xcolor t :image-input-type "xdv" :image-output-type "svg" :image-size-adjust
          (1.7 . 1.5)
          :latex-compiler
          ("xelatex -no-pdf -interaction nonstopmode -output-directory %o %f")
          :image-converter
          ("dvisvgm %f -n -b min -c %S -o %O"))
       (imagemagick :programs
              ("latex" "convert")
              :description "pdf > png" :message "you need to install the programs: latex and imagemagick." :use-xcolor t :image-input-type "pdf" :image-output-type "png" :image-size-adjust
              (1.0 . 1.0)
              :latex-compiler
              ("xelatex -no-pdf -interaction nonstopmode -output-directory %o %f")
              :image-converter
              ("convert -density %D -trim -antialias %f -quality 100 %O"))))
#+end_src

*** Exporting
**** Exporting Org code

With all our Org config and hooks, exporting an Org code block when using
a font-lock based method can produce undesirable results. To address this, we
can tweak ~+org-babel-mode-alist~ when exporting.

#+begin_src emacs-lisp
(defun +org-mode--fontlock-only-mode ()
  "Just apply org-mode's font-lock once."
  (let (org-mode-hook
        org-hide-leading-stars
        org-hide-emphasis-markers)
    (org-set-font-lock-defaults)
    (font-lock-ensure))
  (setq-local major-mode #'fundamental-mode))

(defun +org-export-babel-mask-org-config (_backend)
  "Use `+org-mode--fontlock-only-mode' instead of `org-mode'."
  (setq-local org-src-lang-modes
              (append org-src-lang-modes
                      (list (cons "org" #'+org-mode--fontlock-only)))))

(add-hook 'org-export-before-processing-hook #'+org-export-babel-mask-org-config)
#+end_src

**** General settings
#+begin_src emacs-lisp
(setq org-export-headline-levels 5) ; I like nesting
#+end_src
I'm also going to make use of an item in =ox-extra= so that I can add an =:ignore:=
tag to headings for the content to be kept, but the heading itself ignored
(unlike =:noexport:= which ignored both heading and content). This is useful when
I want to use headings to provide a structure for writing that doesn't appear in
the final documents.
#+begin_src emacs-lisp
(require 'ox-extra)
(ox-extras-activate '(ignore-headlines))
#+end_src

*** LaTeX Export
**** Compiling
By default Org uses ~pdflatex~ \times 3 + ~bibtex~. This simply won't do in our
modern world. ~latexmk~ + ~biber~ (which is used automatically with ~latexmk~) is a
simply superior combination.

#+begin_src emacs-lisp
;; org-latex-compilers = ("pdflatex" "xelatex" "lualatex"), which are the possible values for %latex
;; (setq org-latex-pdf-process '("latexmk -f -pdf -%latex -shell-escape -interaction=nonstopmode -output-directory=%o %f"))
(setq org-latex-pdf-process '("LC_ALL=en_US.UTF-8 latexmk -f -pdf -%latex -shell-escape -interaction=nonstopmode -output-directory=%o %f"))
#+end_src

While ~org-latex-pdf-process~ does support a function, and we could use that
instead, this would no longer use the log buffer --- it's a bit blind, you give
it the file name and expect it to do its thing.

The default values of ~org-latex-compilers~ is given in commented form to see how
~org-latex-pdf-process~ works with them.

While the ~-%latex~ above is slightly hacky (~-pdflatex~ expects to be given a
value) it allows us to leave ~org-latex-compilers~ unmodified.
This is nice in case I open an org file that uses =#+LATEX_COMPILER= for example,
it should still work.

**** Class templates
#+begin_src emacs-lisp :noweb no-export
(after! ox-latex
  (add-to-list 'org-latex-classes
               '("scr-article"
                 "\\documentclass{scrartcl}"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
  (add-to-list 'org-latex-classes
               '("blank"
                 "[NO-DEFAULT-PACKAGES]\n[NO-PACKAGES]\n[EXTRA]"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
  (add-to-list 'org-latex-classes
               '("bmc-article"
                 "\\documentclass[article,code,maths]{bmc}\n[NO-DEFAULT-PACKAGES]\n[NO-PACKAGES]\n[EXTRA]"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
  (add-to-list 'org-latex-classes
               '("bmc"
                 "\\documentclass[code,maths]{bmc}\n[NO-DEFAULT-PACKAGES]\n[NO-PACKAGES]\n[EXTRA]"
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
  (add-to-list 'org-latex-classes
               '("memoir" "\\documentclass{memoir}"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
  (add-to-list 'org-latex-classes
               '("scrlttr2" "\\documentclass{scrlttr2}"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
  )

(setq org-latex-default-class "scr-article"
      org-latex-tables-booktabs t
      )
#+end_src
**** Extra special strings
LaTeX already recognises =---= and =--= as em/en-dashes, =\-= as a shy hyphen, and the
conversion of =...= to =\ldots{}= is hardcoded into ~org-latex-plain-text~ (unlike
~org-html-plain-text~).

I'd quite like to also recognise =->= and =<-=, so let's set come up with some advice.

#+begin_src emacs-lisp
(defvar org-latex-extra-special-string-regexps
  '(("->" . "\\\\textrightarrow{}")
    ("<-" . "\\\\textleftarrow{}")))

(defun org-latex-convert-extra-special-strings (string)
  "Convert special characters in STRING to LaTeX."
  (dolist (a org-latex-extra-special-string-regexps string)
    (let ((re (car a))
          (rpl (cdr a)))
      (setq string (replace-regexp-in-string re rpl string t)))))

(defadvice! org-latex-plain-text-extra-special-a (orig-fn text info)
  "Make `org-latex-plain-text' handle some extra special strings."
  :around #'org-latex-plain-text
  (let ((output (funcall orig-fn text info)))
    (when (plist-get info :with-special-strings)
      (setq output (org-latex-convert-extra-special-strings output)))
    output))
#+end_src

**** Make verbatim different to code
Since have just gone to so much effort above let's make the most of it by making
=verbatim= use ~verb~ instead of ~protectedtexttt~ (default).

This gives the same advantages as mentioned in the [[*Make verbatim different to code][HTML export section]].

#+begin_src emacs-lisp
(setq org-latex-text-markup-alist
      '((bold . "\\textbf{%s}")
        (code . protectedtexttt)
        (italic . "\\emph{%s}")
        (strike-through . "\\sout{%s}")
        (underline . "\\uline{%s}")
        (verbatim . verb)))
#+end_src
**** Support images from URLs
You can link to remote images easily, and they work nicely with HTML-based
exports. However, LaTeX can only include local files, and so the current
behaviour of =org-latex-link= is just to insert a URL to the image.

We can do better than that by downloading the image to a predictable location,
and using that. By making the filename predictable as opposed to just another
tempfile, this can provide a caching mechanism.

#+begin_src emacs-lisp
(defadvice! +org-latex-link (orig-fn link desc info)
  "Acts as `org-latex-link', but supports remote images."
  :around #'org-latex-link
  (setq o-link link
        o-desc desc
        o-info info)
  (if (and (member (plist-get (cadr link) :type) '("http" "https"))
           (member (file-name-extension (plist-get (cadr link) :path))
                   '("png" "jpg" "jpeg" "pdf" "svg")))
      (org-latex-link--remote link desc info)
    (funcall orig-fn link desc info)))

(defun org-latex-link--remote (link _desc info)
  (let* ((url (plist-get (cadr link) :raw-link))
         (ext (file-name-extension url))
         (target (format "%s%s.%s"
                         (temporary-file-directory)
                         (replace-regexp-in-string "[./]" "-"
                                                   (file-name-sans-extension (substring (plist-get (cadr link) :path) 2)))
                         ext)))
    (unless (file-exists-p target)
      (url-copy-file url target))
    (setcdr link (--> (cadr link)
                   (plist-put it :type "file")
                   (plist-put it :path target)
                   (plist-put it :raw-link (concat "file:" target))
                   (list it)))
    (concat "% fetched from " url "\n"
            (org-latex--inline-image link info))))
#+end_src
**** Pretty code blocks

We could just use minted for syntax highlighting --- however, we can do better!
The =engrave-faces= package lets us use Emacs' font-lock for syntax highlighting,
exporting that as LaTeX commands.

#+begin_src emacs-lisp :noweb-ref none :tangle packages.el
(package! engrave-faces :recipe (:host github :repo "tecosaur/engrave-faces"))
#+end_src

#+begin_src emacs-lisp :noweb-ref none :tangle yes
(use-package! engrave-faces-latex
  :config
  (setq engrave-faces-preset-styles (engrave-faces-generate-preset))
  :after ox-latex)
#+end_src

We'll modify the way listings are generated to make using this as easy as:
#+begin_src emacs-lisp
(setq org-latex-listings 'engraved) ; NOTE non-standard value
#+end_src

Thanks to ~org-latex-conditional-features~ and some copy-paste with the =minted=
entry in ~org-latex-scr-block~ we can easily add this as a recognised
~org-latex-listings~ value.

#+begin_src emacs-lisp :noweb no-export
(defvar-local org-export-has-code-p nil)

(defadvice! org-export-expect-no-code (&rest _)
  :before #'org-export-as
  (setq org-export-has-code-p nil))

(defadvice! org-export-register-code (&rest _)
  :after #'org-latex-src-block
  :after #'org-latex-inline-src-block-engraved
  (setq org-export-has-code-p t))
#+end_src

Whenever this is used, in order for it to actually work (and look a little
better) we add bit to the preamble:

# One little annoyance with this is the interaction between microtype and =Verbatim=
# environments. Protrusion is not desirable here. Thankfully, we can patch the
# =Verbatim= environment to turn off protrusion locally.
# #+begin_src emacs-lisp
# (add-to-list 'org-latex-feature-implementations
#              '(.no-protrusion-in-code :snippet "\\ifcsname Code\\endcsname\n  \\let\\oldcode\\Code\\renewcommand{\\Code}{\\microtypesetup{protrusion=false}\\oldcode}\n\\fi"
#                                       :when microtype
#                                       :eager t
#                                       :order 98.5) t)
# #+end_src

At some point it would be nice to make the box colours easily customisable. At
the moment it's fairly easy to change the syntax highlighting colours with
src_elisp{(setq engrave-faces-preset-styles (engrave-faces-generate-preset))},
but perhaps a toggle which specifies whether to use the default values, the
current theme, or any named theme could be a good idea. It should also possible
to set the box background dynamically to match. The named theme could work by
looking for a style definition with a certain name in a cache dir, and then
switching to that theme and producing (and saving) the style definition if it
doesn't exist.

Now let's have the example block be styled similarly.
#+begin_src emacs-lisp
(defadvice! org-latex-example-block-engraved (orig-fn example-block contents info)
  "Like `org-latex-example-block', but supporting an engraved backend"
  :around #'org-latex-example-block
  (let ((output-block (funcall orig-fn example-block contents info)))
    (if (eq 'engraved (plist-get info :latex-listings))
        (format "\\begin{Code}[alt]\n%s\n\\end{Code}" output-block)
      output-block)))
#+end_src

In addition to the vastly superior visual output, this should also be much
faster to compile for code-heavy documents (like this config).

Performing a little benchmark with this document, I find that this is indeed the
case.

| LaTeX syntax highlighting backend | Compile time | Overhead | Overhead ratio |
|-----------------------------------+--------------+----------+----------------|
| verbatim                          | 12 s         | 0        |            0.0 |
| lstlistings                       | 15 s         | 3 s      |            0.2 |
| Engrave                           | 34 s         | 22 s     |            1.8 |
| Pygments (Minted)                 | 184 s        | 172 s    |           14.3 |
#+TBLFM: $3=$2-@2$2::$4=$3 / @2$2;%.1f

Treating the verbatim (no syntax highlighting) result as a baseline; this
rudimentary test suggest that =engrave-faces= is around eight times faster than
=pygments=, and takes three times as long as no syntax highlighting (verbatim).

*** Beamer Export
It's nice to use a different theme by default
#+begin_src emacs-lisp
(setq org-beamer-theme "[progressbar=foot]metropolis")
#+end_src

And I think that it's natural to divide a presentation into sections, e.g.
Introduction, Overview... so let's set bump up the headline level that becomes a
frame from ~1~ to ~2~.
#+begin_src emacs-lisp
(setq org-beamer-frame-level 2)
#+end_src
*** ASCII export

To start with, why settle for ASCII when UTF-8 exists?
#+begin_src emacs-lisp
(setq org-ascii-charset 'utf-8)
#+end_src

The ASCII export is generally fairly nice. I think the main aspect that could
benefit from improvement is the appearance of LaTeX fragments. There's a nice
utility we can use to create unicode representation, which are much nicer.
It's called ~latex2text~, and it's part of the =pylatexenc= package, and it's [[https://repology.org/project/python:pylatexenc/versions][not
really packaged]]. So, we'll resort to installing it with =pip=.

#+begin_src shell :tangle (if (executable-find "latex2text") "no" "setup.sh")
sudo python3 -m pip install pylatexenc
#+end_src

With that installed, we can override the src_elisp{(org-ascii-latex-fragment)} and
src_elisp{(org-ascii-latex-environment)} functions, which are conveniently very
slim --- just extracting the content, and indenting. We'll only do something
different when =utf-8= is set.

#+begin_src emacs-lisp :noweb-ref none :tangle (if (executable-find "latex2text") "yes" "no")
(after! ox-ascii
  (defvar org-ascii-convert-latex t
    "Use latex2text to convert LaTeX elements to unicode.")

  (defadvice! org-ascii-latex-environment-unicode-a (latex-environment _contents info)
    "Transcode a LATEX-ENVIRONMENT element from Org to ASCII, converting to unicode.
CONTENTS is nil.  INFO is a plist holding contextual
information."
    :override #'org-ascii-latex-environment
    (when (plist-get info :with-latex)
      (org-ascii--justify-element
       (org-remove-indentation
        (let* ((latex (org-element-property :value latex-environment))
               (unicode (and (eq (plist-get info :ascii-charset) 'utf-8)
                             org-ascii-convert-latex
                             (doom-call-process "latex2text" "-q" "--code" latex))))
          (if (= (car unicode) 0) ; utf-8 set, and sucessfully ran latex2text
              (cdr unicode) latex)))
       latex-environment info)))

  (defadvice! org-ascii-latex-fragment-unicode-a (latex-fragment _contents info)
    "Transcode a LATEX-FRAGMENT object from Org to ASCII, converting to unicode.
CONTENTS is nil.  INFO is a plist holding contextual
information."
    :override #'org-ascii-latex-fragment
    (when (plist-get info :with-latex)
      (let* ((latex (org-element-property :value latex-fragment))
             (unicode (and (eq (plist-get info :ascii-charset) 'utf-8)
                           org-ascii-convert-latex
                             (doom-call-process "latex2text" "-q" "--code" latex))))
        (if (and unicode (= (car unicode) 0)) ; utf-8 set, and sucessfully ran latex2text
            (cdr unicode) latex)))))
#+end_src

*** Reveal export
By default reveal is rather nice, there are just a few tweaks that I consider a
good idea.

#+begin_src emacs-lisp
(setq org-re-reveal-theme "white"
      org-re-reveal-transition "slide"
      org-re-reveal-plugins '(markdown notes math search zoom))
#+end_src
** Plaintext
*** Ansi colours

It's nice to see ANSI colour codes displayed. However, until Emacs 28 it's not
possible to do this without modifying the buffer, so let's condition this block
on that.

#+begin_src emacs-lisp
(after! text-mode
  (add-hook! 'text-mode-hook
    (unless (derived-mode-p 'org-mode)
      ;; Apply ANSI color codes
      (with-silent-modifications
        (ansi-color-apply-on-region (point-min) (point-max) t)))))
#+end_src

It's nice to see ANSI colour codes displayed
#+begin_src emacs-lisp
(after! text-mode
  (add-hook! 'text-mode-hook
             ;; Apply ANSI color codes
             (with-silent-modifications
               (ansi-color-apply-on-region (point-min) (point-max)))))
#+end_src
** Python
#+begin_src emacs-lisp
(after! lsp-python-ms
  (setq lsp-python-ms-executable (executable-find "python-language-server"))
  (set-lsp-priority! 'mspyls 1))
#+end_src
** Rust
Set rust-analyzer as prefered lsp-server.
#+begin_src emacs-lisp
(setq rustic-lsp-server 'rust-analyzer)
#+end_src
** CSharp
#+begin_src emacs-lisp
(use-package! html-mode
  :mode "\\.cshtml\\'"
  )
#+end_src
** HTML
#+begin_src emacs-lisp
(setq-hook! 'web-mode-hook +format-with-lsp nil)
(setq-hook! 'web-mode-hook +format-with 'prettier)
#+end_src

* Functions
** Org
Export pdf asynchronously
#+begin_src emacs-lisp
(defun leniviy/org-save-and-export-pdf ()
  (interactive)
  (if (eq major-mode 'org-mode)
      (org-latex-export-to-pdf :async t)))
#+end_src

Export TeX
#+begin_src emacs-lisp
(defun leniviy/org-save-and-export-latex ()
  (interactive)
  (if (eq major-mode 'org-mode)
      (org-latex-export-to-latex :async t)))
(defun leniviy/org-save-and-export-beamer ()
  (if (eq major-mode 'org-mode)
      (org-beamer-export-to-latex :async t)))
#+end_src

config tangling
#+begin_src emacs-lisp
(defun config-tangle ()
  (interactive)
  (shell-command
   "emacs --batch --eval \"(require 'org)\" --eval '(org-babel-tangle-file \"~/.config/doom/config.org\")'"
   ;; (concat "org-tangle " doom-private-dir "config.org" " &")
   )
  )

()
#+end_src
** Files
#+begin_src emacs-lisp
(defun open-file-external (file)
  (interactive "f")
  (let ((process-connection-type nil))
    (start-process
     "" nil shell-file-name
     shell-command-switch
     (format "nohup 1>/dev/null 2>/dev/null xdg-open %s"
             (expand-file-name file)))))

;; (defun get-current-file-location ()
;;   "Return the current file location."
;;   (interactive)
;;   (when buffer-file-name
;;     (file-truename buffer-file-name)))

(defun copy-file-location-to-clipboard ()
  "Copy the current file location to the clipboard."
  (interactive)
  (kill-new (buffer-file-name))
  (message "File location copied to clipboard: %s" (buffer-file-name)))
#+end_src
